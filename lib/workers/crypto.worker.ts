/**
 * Crypto Web Worker
 * Offloads heavy cryptographic operations to a background thread
 * to keep the main UI responsive during file encryption/decryption.
 *
 * SECURITY: Nonces should be generated by the client using NonceManager
 * to ensure counter-based nonce generation across the application.
 * Random nonce fallback is only for backward compatibility.
 */

// Message types for communication
interface CryptoWorkerMessage {
    type: 'encrypt' | 'decrypt' | 'hash' | 'derive-key';
    id: string;
    payload: unknown;
}

interface EncryptPayload {
    data: ArrayBuffer;
    key: ArrayBuffer;
    nonce?: ArrayBuffer;
}

interface DecryptPayload {
    ciphertext: ArrayBuffer;
    key: ArrayBuffer;
    nonce: ArrayBuffer;
}

interface HashPayload {
    data: ArrayBuffer;
}

interface DeriveKeyPayload {
    password: string;
    salt: ArrayBuffer;
}

// Worker context
const ctx: Worker = self as unknown as Worker;

/**
 * Generate random bytes
 */
function _randomBytes(length: number): Uint8Array {
    return crypto.getRandomValues(new Uint8Array(length));
}

/**
 * AES-256-GCM Encryption
 *
 * SECURITY: The nonce MUST be provided by the client using NonceManager
 * for counter-based nonce generation. Random nonces are NOT allowed
 * as they have birthday paradox collision risk with AES-GCM.
 */
async function encrypt(data: ArrayBuffer, key: ArrayBuffer, providedNonce?: ArrayBuffer): Promise<{ ciphertext: ArrayBuffer; nonce: ArrayBuffer }> {
    // SECURITY: Nonce MUST be provided - random nonces are not allowed
    // This prevents birthday paradox attacks on AES-GCM
    if (!providedNonce) {
        throw new Error(
            'SECURITY ERROR: Counter-based nonce must be provided. ' +
            'Random nonces are not allowed due to collision risk. ' +
            'Use NonceManager on the client to generate counter-based nonces.'
        );
    }

    const nonceArray = new Uint8Array(providedNonce);

    // Validate nonce length (must be 12 bytes / 96 bits for AES-GCM)
    if (nonceArray.length !== 12) {
        throw new Error(`Invalid nonce length: ${nonceArray.length}. Must be 12 bytes for AES-GCM.`);
    }

    const cryptoKey = await crypto.subtle.importKey(
        'raw',
        key,
        { name: 'AES-GCM' },
        false,
        ['encrypt']
    );

    const ciphertext = await crypto.subtle.encrypt(
        {
            name: 'AES-GCM',
            iv: new Uint8Array(nonceArray) as BufferSource,
            tagLength: 128,
        },
        cryptoKey,
        data
    );

    return {
        ciphertext,
        nonce: new Uint8Array(nonceArray).buffer as ArrayBuffer
    };
}

/**
 * AES-256-GCM Decryption
 */
async function decrypt(ciphertext: ArrayBuffer, key: ArrayBuffer, nonce: ArrayBuffer): Promise<ArrayBuffer> {
    const cryptoKey = await crypto.subtle.importKey(
        'raw',
        key,
        { name: 'AES-GCM' },
        false,
        ['decrypt']
    );

    return crypto.subtle.decrypt(
        {
            name: 'AES-GCM',
            iv: nonce,
            tagLength: 128,
        },
        cryptoKey,
        ciphertext
    );
}

/**
 * SHA-256 Hash
 */
async function hash(data: ArrayBuffer): Promise<ArrayBuffer> {
    return crypto.subtle.digest('SHA-256', data);
}

/**
 * Derive key from password using Argon2id (with PBKDF2 fallback)
 *
 * SECURITY: Uses Argon2id when available for memory-hard key derivation
 * Falls back to PBKDF2 with 600K iterations when WASM is unavailable
 */
async function deriveKey(password: string, salt: ArrayBuffer): Promise<ArrayBuffer> {
    const saltArray = new Uint8Array(salt);

    try {
        // Try Argon2id first (via hash-wasm WASM)
        const { argon2id } = await import('hash-wasm');

        const result = await argon2id({
            password,
            salt: saltArray,
            parallelism: 4,
            iterations: 3,
            memorySize: 65536, // 64 MiB
            hashLength: 32,
            outputType: 'binary',
        });

        return new Uint8Array(result).buffer as ArrayBuffer;
    } catch {
        // Fallback to PBKDF2 with 600K iterations (OWASP 2023)
        const encoder = new TextEncoder();
        const passwordKey = await crypto.subtle.importKey(
            'raw',
            encoder.encode(password),
            'PBKDF2',
            false,
            ['deriveBits']
        );

        const keyBits = await crypto.subtle.deriveBits(
            {
                name: 'PBKDF2',
                hash: 'SHA-256',
                salt: salt,
                iterations: 600000,
            },
            passwordKey,
            256
        );

        return keyBits;
    }
}

/**
 * Handle incoming messages
 */
ctx.onmessage = async (event: MessageEvent<CryptoWorkerMessage>) => {
    const { type, id, payload } = event.data;

    try {
        let result: unknown;

        switch (type) {
            case 'encrypt': {
                const { data, key, nonce } = payload as EncryptPayload;
                result = await encrypt(data, key, nonce);
                break;
            }
            case 'decrypt': {
                const { ciphertext, key, nonce } = payload as DecryptPayload;
                result = await decrypt(ciphertext, key, nonce);
                break;
            }
            case 'hash': {
                const { data } = payload as HashPayload;
                result = await hash(data);
                break;
            }
            case 'derive-key': {
                const { password, salt } = payload as DeriveKeyPayload;
                result = await deriveKey(password, salt);
                break;
            }
            default:
                throw new Error(`Unknown message type: ${type}`);
        }

        ctx.postMessage({ id, success: true, result });
    } catch (error) {
        ctx.postMessage({
            id,
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error'
        });
    }
};

// Signal that worker is ready
ctx.postMessage({ type: 'ready' });
