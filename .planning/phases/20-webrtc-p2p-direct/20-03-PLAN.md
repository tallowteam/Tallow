---
phase: 20-webrtc-p2p-direct
plan: 03
type: execute
wave: 3
depends_on: ["20-02"]
files_modified:
  - crates/tallow-net/src/transport/p2p.rs
  - crates/tallow-net/src/nat/candidates.rs
  - crates/tallow-protocol/src/wire/messages.rs
autonomous: true
requirements:
  - P2P-01
  - P2P-02
  - P2P-03
  - P2P-04
  - P2P-05
  - P2P-06
  - P2P-07
  - P2P-08

must_haves:
  truths:
    - "Two local peers can exchange candidates and establish a direct QUIC connection via hole punch in integration test"
    - "When one peer sends DirectFailed, the other falls back to relay without hanging"
    - "Candidate address encode/decode round-trips correctly for both IPv4 and IPv6"
    - "Invalid candidate addresses (loopback, multicast, unspecified, link-local, port 0) are rejected"
    - "All 4 new Message variants have stable postcard discriminants"
    - "Old Message variants still decode correctly after new variants are appended"
  artifacts:
    - path: "crates/tallow-net/src/transport/p2p.rs"
      provides: "Integration test for local P2P upgrade"
      contains: "test_local_p2p"
    - path: "crates/tallow-net/src/nat/candidates.rs"
      provides: "Candidate encode/decode and validation tests"
      contains: "test_encode_decode"
    - path: "crates/tallow-protocol/src/wire/messages.rs"
      provides: "Discriminant stability test for P2P variants"
      contains: "test_discriminant_stability_p2p"
  key_links:
    - from: "crates/tallow-net/src/transport/p2p.rs"
      to: "crates/tallow-net/src/transport/direct.rs"
      via: "DirectListener + connect_direct in integration test"
      pattern: "DirectListener.*connect_direct"
---

<objective>
Add comprehensive tests verifying the P2P negotiation pipeline, candidate system, and backward compatibility of wire protocol changes.

Purpose: Ensure the P2P direct connection system works correctly in all scenarios (success, failure, symmetric NAT, proxy mode) and that the wire protocol changes do not break backward compatibility with existing peers/relays.

Output: Integration test for local P2P upgrade, unit tests for all candidate operations, discriminant stability tests, backward compat verification.
</objective>

<execution_context>
@C:/Users/Aamir/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Aamir/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-webrtc-p2p-direct/20-01-SUMMARY.md
@.planning/phases/20-webrtc-p2p-direct/20-02-SUMMARY.md

# Implementation files to test
@crates/tallow-net/src/transport/p2p.rs
@crates/tallow-net/src/nat/candidates.rs
@crates/tallow-net/src/transport/direct.rs
@crates/tallow-protocol/src/wire/messages.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add P2P integration test and candidate edge case tests</name>
  <files>
    crates/tallow-net/src/transport/p2p.rs
    crates/tallow-net/src/nat/candidates.rs
  </files>
  <action>
**1. Add integration test to `crates/tallow-net/src/transport/p2p.rs`** in the `#[cfg(test)]` module.

This test verifies the core hole punch flow using two local endpoints (simulating two peers on the same machine):

```rust
#[cfg(test)]
#[cfg(feature = "quic")]
mod tests {
    use super::*;
    use crate::transport::direct::{DirectListener, connect_direct};
    use crate::transport::PeerChannel;

    #[test]
    fn test_negotiation_result_variants() {
        let fallback = NegotiationResult::FallbackToRelay("test reason".to_string());
        assert!(matches!(fallback, NegotiationResult::FallbackToRelay(_)));
        let debug = format!("{:?}", fallback);
        assert!(debug.contains("FallbackToRelay"));
        assert!(debug.contains("test reason"));
    }

    /// Test that the hole punch flow works between two local endpoints.
    /// This tests the DirectListener (server) + connect_direct (client) path
    /// that negotiate_p2p uses internally.
    #[tokio::test(flavor = "multi_thread", worker_threads = 2)]
    async fn test_local_p2p_connection() {
        // Server: bind a listener on loopback
        let listener = DirectListener::bind_to(
            "127.0.0.1:0".parse().unwrap()
        ).unwrap();
        let server_addr = listener.local_addr();

        // Spawn server accept
        let server_handle = tokio::spawn(async move {
            let mut server = listener.accept_peer(
                Duration::from_secs(5)
            ).await.unwrap();

            // Receive a test message
            let mut buf = vec![0u8; 1024];
            let n = server.receive_message(&mut buf).await.unwrap();
            assert_eq!(&buf[..n], b"p2p-test-data");

            // Echo back
            server.send_message(b"p2p-test-ack").await.unwrap();
            server
        });

        // Client: connect to server
        let mut client = connect_direct(
            server_addr,
            Duration::from_secs(5),
        ).await.unwrap();

        // Send test data
        client.send_message(b"p2p-test-data").await.unwrap();

        // Receive ack
        let mut buf = vec![0u8; 1024];
        let n = client.receive_message(&mut buf).await.unwrap();
        assert_eq!(&buf[..n], b"p2p-test-ack");

        // Verify transport description mentions "direct"
        let desc = client.transport_description();
        assert!(
            desc.contains("direct"),
            "Transport description should mention 'direct': {}",
            desc
        );

        let mut server = server_handle.await.unwrap();
        client.close().await;
        server.close().await;
    }

    /// Test that candidate exchange message variants round-trip through postcard
    #[test]
    fn test_candidate_message_roundtrip() {
        use tallow_protocol::wire::Message;

        let msgs = vec![
            Message::CandidateOffer {
                candidate_type: 0,
                addr: vec![192, 168, 1, 42, 0x1F, 0x90], // 192.168.1.42:8080
                priority: 100,
            },
            Message::CandidateOffer {
                candidate_type: 1,
                addr: vec![8, 8, 8, 8, 0x11, 0x51], // 8.8.8.8:4433
                priority: 50,
            },
            Message::CandidatesDone,
            Message::DirectConnected,
            Message::DirectFailed,
        ];

        for msg in &msgs {
            let bytes = postcard::to_stdvec(msg).unwrap();
            let decoded: Message = postcard::from_bytes(&bytes).unwrap();
            assert_eq!(&decoded, msg, "round-trip failed for {:?}", msg);
        }
    }

    /// Test timeout behavior: attempting to connect to unreachable address
    #[tokio::test]
    async fn test_hole_punch_timeout() {
        // Use a non-routable address that will time out
        let result = connect_direct(
            "192.0.2.1:1234".parse().unwrap(), // TEST-NET, should not route
            Duration::from_millis(500),
        ).await;
        assert!(result.is_err(), "Connection to unreachable address should fail");
    }
}
```

**2. Add edge case tests to `crates/tallow-net/src/nat/candidates.rs`** in the `#[cfg(test)]` module.

Add these additional tests to the existing test module:

```rust
#[test]
fn test_candidate_type_values() {
    assert_eq!(CandidateType::Host as u8, 0);
    assert_eq!(CandidateType::ServerReflexive as u8, 1);
    assert_eq!(CandidateType::UPnP as u8, 2);
}

#[test]
fn test_encode_decode_all_ipv4_octets() {
    // Edge case: all zeros
    let addr: SocketAddr = "0.0.0.1:1".parse().unwrap();
    let encoded = encode_socket_addr(addr);
    let decoded = decode_socket_addr(&encoded).unwrap();
    assert_eq!(decoded, addr);

    // Edge case: all 255s (near broadcast)
    let addr: SocketAddr = "255.255.255.254:65535".parse().unwrap();
    let encoded = encode_socket_addr(addr);
    let decoded = decode_socket_addr(&encoded).unwrap();
    assert_eq!(decoded, addr);
}

#[test]
fn test_encode_decode_ipv6_full() {
    let addr: SocketAddr = "[2001:db8::1]:4433".parse().unwrap();
    let encoded = encode_socket_addr(addr);
    assert_eq!(encoded.len(), 18);
    let decoded = decode_socket_addr(&encoded).unwrap();
    assert_eq!(decoded, addr);
}

#[test]
fn test_validate_accepts_private_ranges() {
    // Private ranges are valid candidates (LAN peers)
    assert!(validate_candidate_addr(&"10.0.0.1:8080".parse().unwrap()));
    assert!(validate_candidate_addr(&"172.16.0.1:8080".parse().unwrap()));
    assert!(validate_candidate_addr(&"192.168.0.1:8080".parse().unwrap()));
}

#[test]
fn test_validate_rejects_ipv6_link_local() {
    assert!(!validate_candidate_addr(&"[fe80::1]:8080".parse().unwrap()));
}

#[test]
fn test_validate_rejects_ipv6_multicast() {
    assert!(!validate_candidate_addr(&"[ff02::1]:8080".parse().unwrap()));
}

#[test]
fn test_validate_rejects_ipv6_unspecified() {
    assert!(!validate_candidate_addr(&"[::]:8080".parse().unwrap()));
}

#[test]
fn test_candidate_sorting_by_priority() {
    let mut candidates = vec![
        Candidate {
            addr: "8.8.8.8:4433".parse().unwrap(),
            candidate_type: CandidateType::ServerReflexive,
            priority: 50,
        },
        Candidate {
            addr: "192.168.1.1:4433".parse().unwrap(),
            candidate_type: CandidateType::Host,
            priority: 100,
        },
        Candidate {
            addr: "1.2.3.4:4433".parse().unwrap(),
            candidate_type: CandidateType::UPnP,
            priority: 30,
        },
    ];
    candidates.sort_by(|a, b| b.priority.cmp(&a.priority));
    assert_eq!(candidates[0].priority, 100); // Host first
    assert_eq!(candidates[1].priority, 50);  // SRFLX second
    assert_eq!(candidates[2].priority, 30);  // UPnP last
}

/// Test gather_candidates returns at least a host candidate on most systems
#[tokio::test]
async fn test_gather_candidates_returns_host() {
    // Note: This may fail in some CI environments without network
    let candidates = gather_candidates(0).await;
    // On most systems with a network interface, we get at least a host candidate
    // STUN may fail (no internet) but host should work
    // We don't assert candidates.is_empty() because CI may not have a NIC
    for c in &candidates {
        assert!(c.priority > 0);
        assert!(c.addr.port() == 0 || c.addr.port() > 0);
    }
}
```

**3. Add discriminant stability test to `crates/tallow-protocol/src/wire/messages.rs`** if not already added in Plan 01:

Ensure the test `test_discriminant_stability_p2p_variants` exists and verify exact discriminant values.

Also add a backward compatibility test:

```rust
#[test]
fn test_old_variants_stable_after_phase20() {
    // Verify Phase 19 and earlier variants are unchanged
    let old_messages = vec![
        Message::Ping,
        Message::Pong,
        Message::ChatEnd,
        Message::RoomJoinMulti {
            room_id: vec![0; 32],
            password_hash: None,
            requested_capacity: 5,
        },
        Message::RoomPeerCount {
            count: 3,
            capacity: 10,
        },
    ];
    for msg in &old_messages {
        let bytes = postcard::to_stdvec(msg).unwrap();
        let decoded: Message = postcard::from_bytes(&bytes).unwrap();
        assert_eq!(&decoded, msg, "backward compat failed after Phase 20 for {:?}", msg);
    }
}
```

  </action>
  <verify>
Run: `powershell.exe -NoProfile -Command "& { $env:LIB = 'C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0\um\x64;C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0\ucrt\x64;C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\lib\x64'; $env:INCLUDE = 'C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um;C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt;C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared;C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include'; $env:PATH = 'C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\bin\Hostx64\x64;' + $env:PATH; cargo test --workspace 2>&1 }"` -- all tests pass, including new P2P tests.
  </verify>
  <done>
Comprehensive test suite covers: local P2P connection roundtrip, candidate message encoding/decoding, candidate address validation (all reject cases), candidate priority sorting, postcard discriminant stability for all 4 new variants, backward compatibility for all pre-Phase-20 variants, hole punch timeout behavior.
  </done>
</task>

<task type="auto">
  <name>Task 2: Final clippy, fmt, and full workspace test pass</name>
  <files>
    crates/tallow-net/src/transport/p2p.rs
    crates/tallow-net/src/nat/candidates.rs
    crates/tallow-protocol/src/wire/messages.rs
    crates/tallow/src/commands/send.rs
    crates/tallow/src/commands/receive.rs
    crates/tallow/src/cli.rs
  </files>
  <action>
**1. Run `cargo fmt --check` and fix any formatting issues.**

**2. Run `cargo clippy --workspace -- -D warnings` and fix all warnings.**

Common issues to watch for:
- Unused imports (especially in `p2p.rs` if some functions are only used in one path)
- Unnecessary `pub` on helper functions in `p2p.rs` (keep `negotiate_p2p` and `NegotiationResult` pub, internals private)
- Missing doc comments on public items (add `///` to all pub items per project rules)
- `#![forbid(unsafe_code)]` must be present in `tallow-net` crate root -- no unsafe in p2p.rs or candidates.rs

**3. Run `cargo test --workspace` and ensure all tests pass.**

Check for:
- Tests that rely on network (STUN) may fail in CI. Mark them with `#[ignore]` if they require internet:
  ```rust
  #[tokio::test]
  #[ignore = "requires internet for STUN"]
  async fn test_stun_discovery() { ... }
  ```
- Tests using `DirectListener` on Windows require loopback binding (`127.0.0.1:0` not `0.0.0.0:0`)

**4. Verify no `.unwrap()` in non-test code** (project rule). Grep for `.unwrap()` in the new files:
- `p2p.rs`: should use `?` or `.map_err()` everywhere
- `candidates.rs`: should use `Result` returns

**5. Verify all public items have `///` doc comments** (project rule).

**6. Verify no `println!`** in new code -- use `tracing::info!` / `tracing::warn!` etc.
Exception: JSON output in send.rs/receive.rs uses `println!` for structured JSON events (existing pattern).

  </action>
  <verify>
Run: `powershell.exe -NoProfile -Command "& { $env:LIB = 'C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0\um\x64;C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0\ucrt\x64;C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\lib\x64'; $env:INCLUDE = 'C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um;C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt;C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared;C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include'; $env:PATH = 'C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\bin\Hostx64\x64;' + $env:PATH; cargo fmt --check 2>&1; cargo clippy --workspace -- -D warnings 2>&1; cargo test --workspace 2>&1 }"` -- fmt clean, clippy clean, all tests pass.
  </verify>
  <done>
All code formatted, all clippy warnings resolved, all workspace tests pass. No `.unwrap()` in non-test code, all public items documented, no `println!` outside JSON output paths. Phase 20 implementation is complete.
  </done>
</task>

</tasks>

<verification>
1. `cargo fmt --check` -- clean
2. `cargo clippy --workspace -- -D warnings` -- clean
3. `cargo test --workspace` -- all pass (existing 598+ tests + new P2P tests)
4. `cargo test -p tallow-net -- p2p` -- P2P-specific tests pass
5. `cargo test -p tallow-net -- candidates` -- candidate tests pass
6. `cargo test -p tallow-protocol -- messages` -- all message tests pass including discriminant stability
7. New P2P integration test verifies local peer-to-peer data exchange
8. Backward compatibility: all pre-Phase-20 Message variants round-trip unchanged
</verification>

<success_criteria>
- All workspace tests pass (600+ total)
- No clippy warnings, fmt clean
- P2P integration test proves two local peers can establish direct QUIC connection
- Candidate validation rejects all unsafe address types
- Postcard discriminant stability verified for all variants (old and new)
- No `.unwrap()` in non-test code, no `println!`, all pub items documented
</success_criteria>

<output>
After completion, create `.planning/phases/20-webrtc-p2p-direct/20-03-SUMMARY.md`
</output>
