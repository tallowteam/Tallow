---
phase: 20-webrtc-p2p-direct
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - crates/tallow-net/src/transport/p2p.rs
  - crates/tallow-net/src/transport/mod.rs
  - crates/tallow-net/src/transport/direct.rs
  - crates/tallow/src/commands/send.rs
  - crates/tallow/src/commands/receive.rs
autonomous: true
requirements:
  - P2P-02
  - P2P-03
  - P2P-06
  - P2P-07

must_haves:
  truths:
    - "After KEM handshake, sender and receiver exchange candidates via relay and attempt QUIC hole punch"
    - "When hole punch succeeds, the channel variable swaps from Relay to Direct and transfer proceeds over direct QUIC"
    - "When hole punch fails (timeout or symmetric NAT), transfer continues over the relay with an info message"
    - "When --no-p2p is set or proxy is active, no candidate gathering or hole punch attempt occurs (enforced at both call site AND inside negotiate_p2p via no_p2p guard)"
    - "NAT type is checked before hole punch -- symmetric NAT skips the attempt immediately"
    - "P2P negotiation completes within a bounded timeout (10 seconds max)"
  artifacts:
    - path: "crates/tallow-net/src/transport/p2p.rs"
      provides: "P2P negotiation state machine: candidate exchange, hole punch, connection upgrade"
      contains: "negotiate_p2p"
    - path: "crates/tallow/src/commands/send.rs"
      provides: "P2P upgrade attempt after KEM handshake in send command"
      contains: "negotiate_p2p"
    - path: "crates/tallow/src/commands/receive.rs"
      provides: "P2P upgrade attempt after KEM handshake in receive command"
      contains: "negotiate_p2p"
  key_links:
    - from: "crates/tallow-net/src/transport/p2p.rs"
      to: "crates/tallow-net/src/nat/candidates.rs"
      via: "gather_candidates() for local candidate discovery"
      pattern: "gather_candidates"
    - from: "crates/tallow-net/src/transport/p2p.rs"
      to: "crates/tallow-net/src/transport/direct.rs"
      via: "DirectListener::connect_to()/accept_peer() for QUIC hole punch (endpoint reuse)"
      pattern: "DirectListener.*connect_to|accept_peer"
    - from: "crates/tallow/src/commands/send.rs"
      to: "crates/tallow-net/src/transport/p2p.rs"
      via: "negotiate_p2p() called after handshake completes"
      pattern: "negotiate_p2p"
    - from: "crates/tallow/src/commands/receive.rs"
      to: "crates/tallow-net/src/transport/p2p.rs"
      via: "negotiate_p2p() called after handshake completes"
      pattern: "negotiate_p2p"
---

<objective>
Implement the P2P negotiation module and wire it into the send/receive commands for automatic relay-to-direct connection upgrade after KEM handshake.

Purpose: This is the core P2P logic -- exchange candidates via relay, attempt QUIC hole punching, and swap the channel from relay to direct on success. Without this, peers always communicate through the relay even when a direct path is available.

Output: `p2p.rs` module with `negotiate_p2p()`, send.rs and receive.rs updated with P2P upgrade logic after handshake, user-visible messages for upgrade success/fallback.
</objective>

<execution_context>
@C:/Users/Aamir/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Aamir/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-webrtc-p2p-direct/20-RESEARCH.md
@.planning/phases/20-webrtc-p2p-direct/20-01-SUMMARY.md

# Key existing files
@crates/tallow-net/src/transport/peer_channel.rs
@crates/tallow-net/src/transport/connection.rs
@crates/tallow-net/src/transport/direct.rs
@crates/tallow-net/src/nat/detection.rs
@crates/tallow-net/src/nat/candidates.rs
@crates/tallow/src/commands/send.rs
@crates/tallow/src/commands/receive.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create P2P negotiation module (p2p.rs)</name>
  <files>
    crates/tallow-net/src/transport/p2p.rs
    crates/tallow-net/src/transport/mod.rs
    crates/tallow-net/src/transport/direct.rs
  </files>
  <action>
**1. Create `crates/tallow-net/src/transport/p2p.rs`** with the complete P2P negotiation logic.

The module structure:

```rust
//! P2P direct connection negotiation via QUIC hole punching
//!
//! After the KEM handshake completes over the relay, this module:
//! 1. Gathers local candidates (host IP + STUN reflexive)
//! 2. Exchanges candidates with the remote peer via the relay
//! 3. Attempts QUIC hole punching to the remote candidates
//! 4. Returns a DirectConnection on success, or signals relay fallback

use crate::nat::candidates::{
    gather_candidates, validate_candidate_addr, encode_socket_addr, decode_socket_addr,
    Candidate, CandidateType,
};
use crate::nat::detection::{detect, NatType};
use crate::transport::direct::{DirectListener, DirectConnection};
use crate::transport::PeerChannel;
use crate::{Result, NetworkError};
use std::net::SocketAddr;
use std::time::Duration;
use tallow_protocol::wire::{codec::TallowCodec, Message};
use bytes::BytesMut;

/// Total timeout for the P2P negotiation (STUN + exchange + punch)
pub const P2P_NEGOTIATION_TIMEOUT: Duration = Duration::from_secs(10);

/// Timeout for individual hole punch connection attempt
const HOLE_PUNCH_ATTEMPT_TIMEOUT: Duration = Duration::from_secs(5);

/// Timeout for candidate exchange phase
const CANDIDATE_EXCHANGE_TIMEOUT: Duration = Duration::from_secs(5);

/// Result of P2P negotiation
#[derive(Debug)]
pub enum NegotiationResult {
    /// Direct QUIC connection established
    Direct(DirectConnection),
    /// P2P failed, continue using relay
    FallbackToRelay(String),
}
```

**2. Implement `negotiate_p2p()`:**

```rust
/// Attempt to upgrade from relay to direct P2P QUIC connection.
///
/// This function:
/// 1. Checks `no_p2p` guard (defense-in-depth -- callers should also check, but this
///    ensures future call sites cannot forget the proxy/no-p2p suppression)
/// 2. Detects NAT type (skip if symmetric)
/// 3. Gathers local candidates
/// 4. Exchanges candidates with peer via the relay channel
/// 5. Attempts QUIC hole punch to highest-priority remote candidate
/// 6. Returns DirectConnection on success or fallback reason on failure
///
/// The `channel` must be the relay connection with the peer already joined.
/// The `is_initiator` flag determines QUIC roles: initiator=client, responder=server.
/// Derive from peer ordering (e.g., sender=true, receiver=false).
/// The `no_p2p` flag is a defense-in-depth guard: if true, returns FallbackToRelay
/// immediately. Pass `proxy_config.is_some() || args.no_p2p` from the call site.
pub async fn negotiate_p2p(
    channel: &mut impl PeerChannel,
    is_initiator: bool,
    no_p2p: bool,
) -> NegotiationResult {
    // Defense-in-depth: refuse to negotiate if P2P is suppressed.
    // Callers ALSO check this before calling, but a future caller might forget.
    if no_p2p {
        return NegotiationResult::FallbackToRelay(
            "P2P suppressed (no_p2p flag)".to_string(),
        );
    }

    match tokio::time::timeout(
        P2P_NEGOTIATION_TIMEOUT,
        negotiate_inner(channel, is_initiator),
    ).await {
        Ok(Ok(result)) => result,
        Ok(Err(e)) => {
            tracing::warn!("P2P negotiation error: {}", e);
            NegotiationResult::FallbackToRelay(format!("negotiation error: {}", e))
        }
        Err(_) => {
            tracing::warn!("P2P negotiation timed out");
            NegotiationResult::FallbackToRelay("negotiation timeout".to_string())
        }
    }
}
```

**3. Implement `negotiate_inner()`:**

This is the core logic:

```rust
async fn negotiate_inner(
    channel: &mut impl PeerChannel,
    is_initiator: bool,
) -> Result<NegotiationResult> {
    // Step 1: Detect NAT type
    let nat_type = detect().await.unwrap_or(NatType::Unknown);
    tracing::info!("NAT type detected: {}", nat_type);

    if nat_type == NatType::Symmetric {
        // Send DirectFailed to inform peer we can't hole punch
        send_p2p_msg(channel, &Message::DirectFailed).await?;
        return Ok(NegotiationResult::FallbackToRelay(
            "symmetric NAT detected".to_string(),
        ));
    }

    // Step 2: Bind a QUIC endpoint on a random port for hole punching
    // We need the port BEFORE STUN so STUN discovers the same NAT binding
    let listener = DirectListener::bind().map_err(|e| {
        NetworkError::NatTraversal(format!("Failed to bind hole punch endpoint: {}", e))
    })?;
    let local_port = listener.port();
    tracing::info!("Hole punch endpoint bound on port {}", local_port);

    // Step 3: Gather candidates using the bound port
    let local_candidates = gather_candidates(local_port).await;
    if local_candidates.is_empty() {
        send_p2p_msg(channel, &Message::DirectFailed).await?;
        return Ok(NegotiationResult::FallbackToRelay(
            "no candidates gathered".to_string(),
        ));
    }
    tracing::info!("Gathered {} local candidates", local_candidates.len());

    // Step 4: Send local candidates to peer via relay
    for candidate in &local_candidates {
        let msg = Message::CandidateOffer {
            candidate_type: candidate.candidate_type as u8,
            addr: encode_socket_addr(candidate.addr),
            priority: candidate.priority,
        };
        send_p2p_msg(channel, &msg).await?;
    }
    send_p2p_msg(channel, &Message::CandidatesDone).await?;

    // Step 5: Receive remote candidates from peer
    let remote_candidates = receive_remote_candidates(channel).await?;

    if remote_candidates.is_empty() {
        tracing::info!("Peer sent no candidates (symmetric NAT or P2P disabled)");
        return Ok(NegotiationResult::FallbackToRelay(
            "peer has no candidates".to_string(),
        ));
    }
    tracing::info!("Received {} remote candidates", remote_candidates.len());

    // Step 6: Filter and validate remote candidates
    let valid_candidates: Vec<_> = remote_candidates
        .into_iter()
        .filter(|c| validate_candidate_addr(&c.addr))
        .collect();

    if valid_candidates.is_empty() {
        tracing::warn!("All remote candidates failed validation");
        send_p2p_msg(channel, &Message::DirectFailed).await?;
        return Ok(NegotiationResult::FallbackToRelay(
            "no valid remote candidates".to_string(),
        ));
    }

    // Step 7: Attempt hole punch
    // Both roles use the SAME DirectListener endpoint (bound to port P).
    // Initiator (sender) = QUIC client: connect to remote candidates via listener.connect_to()
    // Responder (receiver) = QUIC server: accept on the listener via listener.accept_peer()
    // This avoids EADDRINUSE -- a single quinn::Endpoint handles both roles.
    let result = if is_initiator {
        attempt_as_client(listener, &valid_candidates).await
    } else {
        attempt_as_server(listener).await
    };

    match result {
        Ok(direct) => {
            tracing::info!(
                "P2P direct connection established to {}",
                direct.remote_addr()
            );
            // Notify peer via relay that direct connection is established
            let _ = send_p2p_msg(channel, &Message::DirectConnected).await;
            Ok(NegotiationResult::Direct(direct))
        }
        Err(e) => {
            tracing::info!("Hole punch failed: {}", e);
            let _ = send_p2p_msg(channel, &Message::DirectFailed).await;
            Ok(NegotiationResult::FallbackToRelay(format!(
                "hole punch failed: {}",
                e
            )))
        }
    }
}
```

**4. Implement helper functions:**

```rust
/// Send a P2P signaling message through the relay channel
async fn send_p2p_msg(channel: &mut impl PeerChannel, msg: &Message) -> Result<()> {
    let mut codec = TallowCodec::new();
    let mut buf = BytesMut::new();
    codec.encode_msg(msg, &mut buf).map_err(|e| {
        NetworkError::ConnectionFailed(format!("encode P2P message failed: {}", e))
    })?;
    channel.send_message(&buf).await
}

/// Receive remote candidates from the peer via relay
async fn receive_remote_candidates(
    channel: &mut impl PeerChannel,
) -> Result<Vec<Candidate>> {
    let mut candidates = Vec::new();
    let mut codec = TallowCodec::new();
    let mut recv_buf = vec![0u8; 4096];

    let deadline = tokio::time::Instant::now() + CANDIDATE_EXCHANGE_TIMEOUT;

    loop {
        let remaining = deadline.saturating_duration_since(tokio::time::Instant::now());
        if remaining.is_zero() {
            tracing::warn!("Candidate exchange timeout");
            break;
        }

        let n = match tokio::time::timeout(
            remaining,
            channel.receive_message(&mut recv_buf),
        ).await {
            Ok(Ok(n)) => n,
            Ok(Err(e)) => {
                tracing::warn!("Error receiving candidate: {}", e);
                break;
            }
            Err(_) => {
                tracing::warn!("Candidate exchange timed out");
                break;
            }
        };

        let mut decode_buf = BytesMut::from(&recv_buf[..n]);
        match codec.decode_msg(&mut decode_buf) {
            Ok(Some(Message::CandidateOffer { candidate_type, addr, priority })) => {
                match decode_socket_addr(&addr) {
                    Ok(socket_addr) => {
                        let ct = match candidate_type {
                            0 => CandidateType::Host,
                            1 => CandidateType::ServerReflexive,
                            2 => CandidateType::UPnP,
                            _ => CandidateType::Host, // default
                        };
                        candidates.push(Candidate {
                            addr: socket_addr,
                            candidate_type: ct,
                            priority,
                        });
                    }
                    Err(e) => {
                        tracing::warn!("Invalid candidate address: {}", e);
                    }
                }
            }
            Ok(Some(Message::CandidatesDone)) => {
                tracing::debug!("Peer candidate exchange complete");
                break;
            }
            Ok(Some(Message::DirectFailed)) => {
                tracing::info!("Peer cannot do P2P (symmetric NAT or disabled)");
                return Ok(Vec::new());
            }
            Ok(other) => {
                tracing::debug!("Unexpected message during candidate exchange: {:?}", other);
                // Not a fatal error -- might be keepalive or other traffic
            }
            Err(e) => {
                tracing::warn!("Failed to decode candidate message: {}", e);
            }
        }
    }

    // Sort by priority descending
    candidates.sort_by(|a, b| b.priority.cmp(&a.priority));
    Ok(candidates)
}

/// Attempt QUIC connection to remote candidates (initiator/client role).
///
/// Reuses the DirectListener's internal quinn::Endpoint for outbound connections
/// via `listener.connect_to()`. This is critical: the endpoint is already bound to
/// port P (the same port STUN discovered), so the OS does NOT need a second bind.
/// Quinn natively supports using a server endpoint for outbound connect().
async fn attempt_as_client(
    listener: DirectListener,
    candidates: &[Candidate],
) -> Result<DirectConnection> {
    // Try candidates in priority order, reusing the listener's endpoint
    for candidate in candidates {
        tracing::info!(
            "Attempting hole punch to {} ({:?}, priority={})",
            candidate.addr, candidate.candidate_type, candidate.priority
        );

        match listener.connect_to(candidate.addr, HOLE_PUNCH_ATTEMPT_TIMEOUT).await {
            Ok(conn) => return Ok(conn),
            Err(e) => {
                tracing::debug!("Hole punch to {} failed: {}", candidate.addr, e);
                continue;
            }
        }
    }
    Err(NetworkError::NatTraversal(
        "All hole punch attempts failed".to_string(),
    ))
}

/// Wait for incoming QUIC connection (responder/server role)
async fn attempt_as_server(
    listener: DirectListener,
) -> Result<DirectConnection> {
    tracing::info!(
        "Waiting for hole punch connection on {}...",
        listener.local_addr()
    );
    listener.accept_peer(HOLE_PUNCH_ATTEMPT_TIMEOUT).await
}
```

**5. Add unit test for NegotiationResult:**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_negotiation_result_debug() {
        let fallback = NegotiationResult::FallbackToRelay("test".to_string());
        let debug = format!("{:?}", fallback);
        assert!(debug.contains("FallbackToRelay"));
    }
}
```

**6. Update `crates/tallow-net/src/transport/mod.rs`:**

Add `pub mod p2p;` to the module declarations and export key types:

```rust
pub mod p2p;
pub use p2p::{negotiate_p2p, NegotiationResult};
```

**7. Add `connect_to()` method to `DirectListener` in `direct.rs`:**

The existing `DirectListener` creates a `quinn::Endpoint` configured as a server. Quinn natively supports using a server endpoint for outbound `connect()` calls too -- a single `quinn::Endpoint` can both accept incoming connections AND initiate outbound connections on the same UDP socket.

**DO NOT** create a separate `connect_direct_from_port()` function that re-binds the same port. That would fail with EADDRINUSE because the `DirectListener` already holds the socket.

Instead, add a `connect_to()` method on `DirectListener` that reuses its internal endpoint:

```rust
/// Initiate an outbound QUIC connection to a peer using this listener's endpoint.
///
/// This reuses the same UDP socket (and port) that the listener is bound to.
/// Quinn natively supports both `accept()` and `connect()` on the same Endpoint.
/// This is critical for hole punching: the outbound connection uses the same
/// local port that STUN discovered, ensuring the NAT pinhole is reused.
pub async fn connect_to(
    &self,
    peer_addr: SocketAddr,
    timeout_dur: Duration,
) -> Result<DirectConnection> {
    // Add client config to the endpoint so it can initiate connections.
    // The endpoint already has a server config from bind().
    let client_config = super::tls_config::quinn_client_config()?;
    let mut lan_client_config = client_config;
    lan_client_config.transport_config(Arc::new(lan_transport_config()));
    self.endpoint.set_default_client_config(lan_client_config);

    let connection = tokio::time::timeout(
        timeout_dur,
        self.endpoint.connect(peer_addr, "localhost").map_err(|e| {
            NetworkError::ConnectionFailed(format!(
                "direct connect initiation failed: {}", e
            ))
        })?,
    )
    .await
    .map_err(|_| NetworkError::Timeout)?
    .map_err(|e| {
        NetworkError::ConnectionFailed(format!(
            "direct QUIC connection failed: {}", e
        ))
    })?;

    let remote_addr = connection.remote_address();
    tracing::info!("Direct P2P connection established to {}", remote_addr);

    // Open a bidirectional stream (client role opens, server role accepts)
    let (send, recv) = connection
        .open_bi()
        .await
        .map_err(|e| {
            NetworkError::ConnectionFailed(format!("direct open_bi failed: {}", e))
        })?;

    Ok(DirectConnection::new(
        self.endpoint.clone(),
        connection,
        send,
        recv,
        remote_addr,
    ))
}
```

Place this method inside the existing `impl DirectListener` block, after `accept_peer()` and before `close()`.

**Why this works:** Quinn's `Endpoint` wraps a single UDP socket. Calling `endpoint.connect()` sends QUIC Initial packets from the same local port that `endpoint.accept()` listens on. This means the NAT pinhole created by STUN (which discovered the public mapping for this port) is reused for the outbound connection. No second bind, no EADDRINUSE.

  </action>
  <verify>
Run: `powershell.exe -NoProfile -Command "& { $env:LIB = 'C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0\um\x64;C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0\ucrt\x64;C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\lib\x64'; $env:INCLUDE = 'C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um;C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt;C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared;C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include'; $env:PATH = 'C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\bin\Hostx64\x64;' + $env:PATH; cargo build --workspace 2>&1; cargo clippy --workspace -- -D warnings 2>&1 }"` -- builds clean, clippy clean.
  </verify>
  <done>
`p2p.rs` module provides complete `negotiate_p2p()` function with `no_p2p` defense-in-depth guard. `DirectListener::connect_to()` method added to direct.rs for endpoint reuse (no EADDRINUSE). Transport mod.rs exports P2P types. Compiles and passes clippy.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire P2P upgrade into send and receive commands</name>
  <files>
    crates/tallow/src/commands/send.rs
    crates/tallow/src/commands/receive.rs
  </files>
  <action>
**1. Add P2P upgrade to `send.rs`** immediately after the `// --- End handshake ---` comment (around line 531):

Insert AFTER `output::color::success("Secure session established (KEM handshake complete)");` and BEFORE `pipeline.set_session_key(...)`:

```rust
// --- P2P Direct Connection Upgrade ---
// Attempt to upgrade from relay to direct P2P QUIC after handshake.
// Skip when: proxy active, --no-p2p set, already direct (LAN)
let mut is_direct = is_direct; // make mutable for possible upgrade
if !is_direct && proxy_config.is_none() && !args.no_p2p {
    if !json {
        output::color::info("Attempting P2P direct connection...");
    }

    // Sender = initiator (QUIC client role)
    // Pass no_p2p=false here (we already checked proxy/no_p2p above),
    // but the defense-in-depth guard inside negotiate_p2p() double-checks.
    let suppress_p2p = proxy_config.is_some() || args.no_p2p;
    match tallow_net::transport::negotiate_p2p(&mut channel, true, suppress_p2p).await {
        tallow_net::transport::NegotiationResult::Direct(direct_conn) => {
            if json {
                println!("{}", serde_json::json!({
                    "event": "p2p_upgrade",
                    "remote_addr": direct_conn.remote_addr().to_string(),
                }));
            } else {
                output::color::success(&format!(
                    "Upgraded to direct P2P connection ({})",
                    direct_conn.remote_addr()
                ));
            }
            channel = tallow_net::transport::ConnectionResult::Direct(direct_conn);
            is_direct = true;
        }
        tallow_net::transport::NegotiationResult::FallbackToRelay(reason) => {
            if json {
                println!("{}", serde_json::json!({
                    "event": "p2p_fallback",
                    "reason": reason,
                }));
            } else {
                output::color::info(&format!(
                    "P2P direct connection failed ({}), continuing via relay",
                    reason
                ));
            }
        }
    }
} else if proxy_config.is_some() || args.no_p2p {
    tracing::debug!(
        "P2P disabled: proxy={}, no_p2p={}",
        proxy_config.is_some(),
        args.no_p2p
    );
}
// --- End P2P Upgrade ---
```

Make sure the `is_direct` variable is declared as `let mut is_direct` in the initial connection block (currently it's bound by pattern matching). Check the existing code and adjust if needed.

**2. Add the same P2P upgrade to `receive.rs`** after the handshake completes.

The exact insertion point in `receive.rs` is AFTER the `// --- End handshake ---` comment and the verification display block, and BEFORE the `// Receive FileOffer` comment. Here is the exact surrounding code to anchor on:

```rust
// --- EXISTING CODE (anchor) ---
    if !json {
        output::color::success("Secure session established (KEM handshake complete)");
    }
    // --- End handshake ---

    // Display verification string for MITM detection (opt-in via --verify)
    if args.verify {
        if json {
            output::verify::display_verification_json(session_key.as_bytes());
        } else {
            output::verify::display_verification(session_key.as_bytes(), true);
        }
    }

    // <-- INSERT P2P UPGRADE BLOCK HERE -->

    // Receive FileOffer
    let n = channel
        .receive_message(&mut recv_buf)
        .await
// --- END EXISTING CODE ---
```

Insert the same P2P upgrade block as send.rs between the verification display and `// Receive FileOffer`, with ONE difference: the receiver is the responder (QUIC server role):

```rust
// Receiver = responder (QUIC server role)
let suppress_p2p = proxy_config.is_some() || args.no_p2p;
match tallow_net::transport::negotiate_p2p(&mut channel, false, suppress_p2p).await {
```

Everything else (the if/else, JSON events, is_direct swap, channel reassignment) is identical to send.rs.

**3. Ensure the channel variable is mutable.** Both send.rs and receive.rs use `let (mut channel, is_direct) = ...`. The `is_direct` needs to be `mut` too: `let (mut channel, mut is_direct) = ...`.

**4. Add output helper functions if needed.** If `output::color::` does not have a suitable function for "Upgraded to P2P" messages, use `output::color::success()` or `output::color::info()` which already exist.

**5. Note on receive.rs:** Unlike send.rs which has `pipeline.set_session_key()` after handshake, receive.rs does NOT call `set_session_key()` until the ReceivePipeline is constructed (after FileOffer). So in receive.rs the P2P upgrade goes after the verification block but before `// Receive FileOffer`.

CRITICAL: The P2P upgrade must happen BEFORE any file data transfer messages. The candidate exchange uses the same relay channel for signaling. Once we start the file offer/accept/chunk protocol, the relay channel is occupied with transfer messages. The upgrade window is between handshake completion and file offer.

  </action>
  <verify>
Run: `powershell.exe -NoProfile -Command "& { $env:LIB = 'C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0\um\x64;C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0\ucrt\x64;C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\lib\x64'; $env:INCLUDE = 'C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um;C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt;C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared;C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include'; $env:PATH = 'C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\bin\Hostx64\x64;' + $env:PATH; cargo build -p tallow 2>&1; cargo clippy -p tallow -- -D warnings 2>&1 }"` -- builds and lints clean. Verify P2P upgrade code is present in both send.rs and receive.rs.
  </verify>
  <done>
P2P upgrade logic wired into both send.rs (as initiator/client) and receive.rs (as responder/server). When `--no-p2p` is set or proxy is active, the upgrade is skipped entirely. On success, user sees "Upgraded to direct P2P connection (addr)". On failure, user sees "P2P direct connection failed (reason), continuing via relay". JSON events emitted for machine-readable output.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` succeeds without errors
2. `cargo clippy --workspace -- -D warnings` is clean
3. `p2p.rs` module exists with `negotiate_p2p()`, `NegotiationResult`, candidate exchange, hole punch logic
4. `direct.rs` has `DirectListener::connect_to()` for outbound connections via existing endpoint (no EADDRINUSE)
5. `send.rs` has P2P upgrade block after handshake (is_initiator=true)
6. `receive.rs` has P2P upgrade block after handshake (is_initiator=false)
7. Both commands skip P2P when `proxy_config.is_some()` or `args.no_p2p`
8. NAT type detection skips hole punch for symmetric NAT
9. All existing tests still pass
</verification>

<success_criteria>
- `negotiate_p2p()` exchanges candidates via relay and attempts QUIC hole punch with bounded timeout
- Sender uses client role (listener.connect_to), receiver uses server role (listener.accept_peer) -- both reuse same endpoint
- Successful hole punch swaps ConnectionResult from Relay to Direct
- Failed hole punch continues over relay with user-visible info message
- --no-p2p and proxy mode prevent all P2P logic from executing
- Symmetric NAT detection short-circuits to relay fallback immediately
- JSON events emitted for p2p_upgrade and p2p_fallback
</success_criteria>

<output>
After completion, create `.planning/phases/20-webrtc-p2p-direct/20-02-SUMMARY.md`
</output>
