---
phase: 20-webrtc-p2p-direct
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/tallow-protocol/src/wire/messages.rs
  - crates/tallow-net/src/nat/candidates.rs
  - crates/tallow-net/src/nat/mod.rs
  - crates/tallow-net/src/nat/stun.rs
  - crates/tallow/src/cli.rs
autonomous: true
requirements:
  - P2P-01
  - P2P-04
  - P2P-05
  - P2P-08

must_haves:
  truths:
    - "New Message variants (CandidateOffer, CandidatesDone, DirectConnected, DirectFailed) round-trip through postcard encode/decode"
    - "Existing Message variants have unchanged discriminant values after appending new variants"
    - "Candidate gathering discovers host IP and STUN server-reflexive address"
    - "STUN discovery can bind to a specific local port (not just 0.0.0.0:0)"
    - "--no-p2p flag exists on SendArgs and ReceiveArgs"
    - "--tor and --proxy flags suppress all P2P candidate gathering"
  artifacts:
    - path: "crates/tallow-protocol/src/wire/messages.rs"
      provides: "P2P signaling message variants appended to Message enum"
      contains: "CandidateOffer"
    - path: "crates/tallow-net/src/nat/candidates.rs"
      provides: "Candidate gathering (host, STUN, address validation)"
      contains: "gather_candidates"
    - path: "crates/tallow-net/src/nat/stun.rs"
      provides: "STUN discovery from a specific local port"
      contains: "discover_from_port"
    - path: "crates/tallow/src/cli.rs"
      provides: "--no-p2p CLI flag on SendArgs and ReceiveArgs"
      contains: "no_p2p"
  key_links:
    - from: "crates/tallow-net/src/nat/candidates.rs"
      to: "crates/tallow-net/src/nat/stun.rs"
      via: "StunClient::discover_from_port()"
      pattern: "discover_from_port"
    - from: "crates/tallow-net/src/nat/mod.rs"
      to: "crates/tallow-net/src/nat/candidates.rs"
      via: "pub mod candidates"
      pattern: "pub mod candidates"
---

<objective>
Add P2P signaling wire protocol variants, candidate gathering infrastructure, STUN port-binding support, and CLI flags for P2P control.

Purpose: Establish the foundation layer (new message types, candidate discovery, CLI flags) that the P2P negotiation module (Plan 02) builds upon. Without this, there is no way to exchange addresses between peers or gather local/public addresses for hole punching.

Output: New `CandidateOffer`/`CandidatesDone`/`DirectConnected`/`DirectFailed` message variants, `candidates.rs` module with `gather_candidates()`, STUN `discover_from_port()`, `--no-p2p` flag on send/receive args.
</objective>

<execution_context>
@C:/Users/Aamir/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Aamir/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-webrtc-p2p-direct/20-RESEARCH.md

# Key existing files
@crates/tallow-protocol/src/wire/messages.rs
@crates/tallow-net/src/nat/stun.rs
@crates/tallow-net/src/nat/detection.rs
@crates/tallow-net/src/nat/mod.rs
@crates/tallow/src/cli.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add P2P signaling Message variants and candidate types</name>
  <files>
    crates/tallow-protocol/src/wire/messages.rs
    crates/tallow-net/src/nat/candidates.rs
    crates/tallow-net/src/nat/mod.rs
  </files>
  <action>
**1. Append four new variants to the `Message` enum** in `crates/tallow-protocol/src/wire/messages.rs`.

Append AFTER the last existing variant (`RoomPeerCount`). NEVER reorder existing variants (postcard discriminant stability). Add these:

```rust
// --- Phase 20: P2P Direct signaling variants (DO NOT reorder; postcard ordinal) ---
/// Candidate address for P2P direct connection attempt
CandidateOffer {
    /// Candidate type: 0 = host, 1 = server-reflexive (STUN), 2 = UPnP
    candidate_type: u8,
    /// Socket address encoded as bytes: 6 bytes (IPv4 u32 BE + port u16 BE) or 18 bytes (IPv6)
    addr: Vec<u8>,
    /// Priority (higher = preferred). Host=100, SRFLX=50, UPnP=30.
    priority: u32,
},
/// All candidates have been sent; peer may begin connection attempts
CandidatesDone,
/// Direct P2P connection established — notify relay to stop forwarding
DirectConnected,
/// Direct P2P connection failed — continue via relay
DirectFailed,
```

**2. Add round-trip tests** for all four new variants in the existing `test_message_roundtrip_all_variants` test. Also add a discriminant stability test:

```rust
#[test]
fn test_discriminant_stability_p2p_variants() {
    // RoomPeerCount was variant index 35 (the last pre-Phase-20 variant).
    // CandidateOffer must be 36, CandidatesDone 37, DirectConnected 38, DirectFailed 39.
    let bytes = postcard::to_stdvec(&Message::CandidateOffer {
        candidate_type: 0,
        addr: vec![],
        priority: 0,
    }).unwrap();
    assert_eq!(bytes[0], 36, "CandidateOffer discriminant must be 36");

    let bytes = postcard::to_stdvec(&Message::CandidatesDone).unwrap();
    assert_eq!(bytes[0], 37, "CandidatesDone discriminant must be 37");

    let bytes = postcard::to_stdvec(&Message::DirectConnected).unwrap();
    assert_eq!(bytes[0], 38, "DirectConnected discriminant must be 38");

    let bytes = postcard::to_stdvec(&Message::DirectFailed).unwrap();
    assert_eq!(bytes[0], 39, "DirectFailed discriminant must be 39");
}
```

Verify the exact discriminant values by counting existing variants (0-indexed). If the count differs from 36, adjust accordingly -- the key point is that existing variants MUST NOT change.

Also verify that the existing `test_discriminant_stability_chat_end` test still passes (ChatEnd must remain 28).

**3. Create `crates/tallow-net/src/nat/candidates.rs`** with:

```rust
//! ICE-like candidate gathering for P2P direct connection
//!
//! Gathers local host addresses and STUN server-reflexive addresses
//! for exchanging with the remote peer via the relay.

use crate::Result;
use crate::error::NetworkError;
use std::net::{IpAddr, Ipv4Addr, SocketAddr};

/// Candidate type for P2P connection
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CandidateType {
    /// Local network interface address
    Host = 0,
    /// STUN server-reflexive (public) address
    ServerReflexive = 1,
    /// UPnP port-mapped address
    UPnP = 2,
}

/// A network candidate for P2P direct connection
#[derive(Debug, Clone)]
pub struct Candidate {
    /// Socket address (IP + port)
    pub addr: SocketAddr,
    /// Type of candidate
    pub candidate_type: CandidateType,
    /// Priority (higher = preferred). Host=100, SRFLX=50, UPnP=30.
    pub priority: u32,
}
```

Add `gather_candidates()` function:

```rust
/// Gather all available candidates for P2P connection.
///
/// Binds to `local_port` for STUN discovery so the discovered public address
/// maps to the same port the quinn Endpoint will use.
///
/// Returns candidates sorted by priority (highest first).
pub async fn gather_candidates(local_port: u16) -> Vec<Candidate> {
    let mut candidates = Vec::new();

    // 1. Host candidates: local network interfaces
    // Use local_ip_address crate or fall back to 0.0.0.0
    if let Ok(ip) = get_local_ip() {
        candidates.push(Candidate {
            addr: SocketAddr::new(ip, local_port),
            candidate_type: CandidateType::Host,
            priority: 100,
        });
    }

    // 2. Server-reflexive candidate: STUN discovery from the same port
    match crate::nat::stun::StunClient::from_hostname(crate::nat::stun::GOOGLE_STUN).await {
        Ok(client) => {
            match client.discover_from_port(local_port).await {
                Ok(result) => {
                    candidates.push(Candidate {
                        addr: result.mapped_addr,
                        candidate_type: CandidateType::ServerReflexive,
                        priority: 50,
                    });
                }
                Err(e) => {
                    tracing::warn!("STUN discovery failed: {}", e);
                }
            }
        }
        Err(e) => {
            tracing::warn!("STUN client creation failed: {}", e);
        }
    }

    // Sort by priority descending
    candidates.sort_by(|a, b| b.priority.cmp(&a.priority));
    candidates
}
```

Add helper functions:

```rust
/// Get the primary local IP address (non-loopback, non-link-local).
fn get_local_ip() -> Result<IpAddr> {
    // Bind a UDP socket to an external address to discover the default route IP
    let socket = std::net::UdpSocket::bind("0.0.0.0:0")
        .map_err(|e| NetworkError::NatTraversal(format!("bind failed: {}", e)))?;
    socket.connect("8.8.8.8:80")
        .map_err(|e| NetworkError::NatTraversal(format!("connect failed: {}", e)))?;
    let addr = socket.local_addr()
        .map_err(|e| NetworkError::NatTraversal(format!("local_addr failed: {}", e)))?;
    Ok(addr.ip())
}

/// Validate a candidate address is safe to connect to.
///
/// Rejects loopback, link-local, broadcast, multicast, and unspecified addresses.
/// Prevents an attacker from redirecting connections to unintended addresses.
pub fn validate_candidate_addr(addr: &SocketAddr) -> bool {
    let ip = addr.ip();
    if ip.is_loopback() || ip.is_multicast() || ip.is_unspecified() {
        return false;
    }
    // Check link-local
    match ip {
        IpAddr::V4(v4) => {
            // 169.254.0.0/16 link-local
            if v4.octets()[0] == 169 && v4.octets()[1] == 254 {
                return false;
            }
            // 255.255.255.255 broadcast
            if v4 == Ipv4Addr::BROADCAST {
                return false;
            }
        }
        IpAddr::V6(v6) => {
            // fe80::/10 link-local
            let segments = v6.segments();
            if segments[0] & 0xffc0 == 0xfe80 {
                return false;
            }
        }
    }
    // Port must be valid (1-65535)
    addr.port() > 0
}

/// Encode a SocketAddr into bytes for wire transport.
/// IPv4: 6 bytes (4 IP + 2 port). IPv6: 18 bytes (16 IP + 2 port).
pub fn encode_socket_addr(addr: SocketAddr) -> Vec<u8> {
    let mut buf = Vec::new();
    match addr.ip() {
        IpAddr::V4(v4) => {
            buf.extend_from_slice(&v4.octets());
            buf.extend_from_slice(&addr.port().to_be_bytes());
        }
        IpAddr::V6(v6) => {
            buf.extend_from_slice(&v6.octets());
            buf.extend_from_slice(&addr.port().to_be_bytes());
        }
    }
    buf
}

/// Decode a SocketAddr from bytes. Inverse of `encode_socket_addr`.
pub fn decode_socket_addr(bytes: &[u8]) -> Result<SocketAddr> {
    match bytes.len() {
        6 => {
            let ip = Ipv4Addr::new(bytes[0], bytes[1], bytes[2], bytes[3]);
            let port = u16::from_be_bytes([bytes[4], bytes[5]]);
            Ok(SocketAddr::new(IpAddr::V4(ip), port))
        }
        18 => {
            let mut octets = [0u8; 16];
            octets.copy_from_slice(&bytes[..16]);
            let ip = std::net::Ipv6Addr::from(octets);
            let port = u16::from_be_bytes([bytes[16], bytes[17]]);
            Ok(SocketAddr::new(IpAddr::V6(ip), port))
        }
        n => Err(NetworkError::NatTraversal(format!(
            "Invalid candidate address length: {} (expected 6 or 18)", n
        ))),
    }
}
```

Add unit tests:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encode_decode_ipv4() {
        let addr: SocketAddr = "192.168.1.42:8080".parse().unwrap();
        let encoded = encode_socket_addr(addr);
        assert_eq!(encoded.len(), 6);
        let decoded = decode_socket_addr(&encoded).unwrap();
        assert_eq!(decoded, addr);
    }

    #[test]
    fn test_encode_decode_ipv6() {
        let addr: SocketAddr = "[::1]:4433".parse().unwrap();
        let encoded = encode_socket_addr(addr);
        assert_eq!(encoded.len(), 18);
        let decoded = decode_socket_addr(&encoded).unwrap();
        assert_eq!(decoded, addr);
    }

    #[test]
    fn test_validate_rejects_loopback() {
        assert!(!validate_candidate_addr(&"127.0.0.1:1234".parse().unwrap()));
        assert!(!validate_candidate_addr(&"[::1]:1234".parse().unwrap()));
    }

    #[test]
    fn test_validate_rejects_link_local() {
        assert!(!validate_candidate_addr(&"169.254.1.1:1234".parse().unwrap()));
    }

    #[test]
    fn test_validate_rejects_broadcast() {
        assert!(!validate_candidate_addr(&"255.255.255.255:1234".parse().unwrap()));
    }

    #[test]
    fn test_validate_rejects_multicast() {
        assert!(!validate_candidate_addr(&"224.0.0.1:1234".parse().unwrap()));
    }

    #[test]
    fn test_validate_rejects_unspecified() {
        assert!(!validate_candidate_addr(&"0.0.0.0:1234".parse().unwrap()));
    }

    #[test]
    fn test_validate_rejects_port_zero() {
        assert!(!validate_candidate_addr(&"192.168.1.1:0".parse().unwrap()));
    }

    #[test]
    fn test_validate_accepts_valid() {
        assert!(validate_candidate_addr(&"192.168.1.42:8080".parse().unwrap()));
        assert!(validate_candidate_addr(&"8.8.8.8:4433".parse().unwrap()));
    }

    #[test]
    fn test_decode_invalid_length() {
        assert!(decode_socket_addr(&[1, 2, 3]).is_err());
    }
}
```

**4. Update `crates/tallow-net/src/nat/mod.rs`** to add `pub mod candidates;` and export the key types:

```rust
pub mod candidates;
pub use candidates::{Candidate, CandidateType};
```

  </action>
  <verify>
Run: `powershell.exe -NoProfile -Command "& { $env:LIB = 'C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0\um\x64;C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0\ucrt\x64;C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\lib\x64'; $env:INCLUDE = 'C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um;C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt;C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared;C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include'; $env:PATH = 'C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\bin\Hostx64\x64;' + $env:PATH; cargo test -p tallow-protocol -- messages 2>&1; cargo test -p tallow-net -- candidates 2>&1 }"` -- all message round-trip tests pass, discriminant stability tests pass, candidate encode/decode/validate tests pass.
  </verify>
  <done>
Four new `Message` variants appended with correct postcard discriminants. `candidates.rs` module provides `gather_candidates()`, `validate_candidate_addr()`, `encode_socket_addr()`, `decode_socket_addr()` with comprehensive tests. All existing message tests still pass unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add STUN port-binding method and --no-p2p CLI flag</name>
  <files>
    crates/tallow-net/src/nat/stun.rs
    crates/tallow/src/cli.rs
  </files>
  <action>
**1. Add `discover_from_port()` to `StunClient`** in `crates/tallow-net/src/nat/stun.rs`.

The existing `discover_public_address()` binds `0.0.0.0:0` (random port). For hole punching, STUN must use the same port as the quinn Endpoint. Add a new method:

```rust
/// Discover public address using STUN, binding from a specific local port.
///
/// This is critical for hole punching: the STUN-discovered mapped address
/// must correspond to the same NAT binding that quinn will use. If we discover
/// from a different port, the NAT maps to a different external port and the
/// candidate is useless.
pub async fn discover_from_port(&self, local_port: u16) -> Result<StunResult> {
    let bind_addr: SocketAddr = SocketAddr::new(
        std::net::IpAddr::V4(std::net::Ipv4Addr::UNSPECIFIED),
        local_port,
    );
    let socket = UdpSocket::bind(bind_addr)
        .await
        .map_err(|e| NetworkError::NatTraversal(format!(
            "Failed to bind UDP socket to port {}: {}", local_port, e
        )))?;

    let local_addr = socket.local_addr().map_err(|e| {
        NetworkError::NatTraversal(format!("Failed to get local address: {}", e))
    })?;

    // Build STUN Binding Request
    let transaction_id: [u8; 12] = rand::random();
    let request = build_binding_request(&transaction_id);

    // Send request
    socket.send_to(&request, self.server).await.map_err(|e| {
        NetworkError::NatTraversal(format!("Failed to send STUN request: {}", e))
    })?;

    // Wait for response (3 second timeout)
    let mut buf = [0u8; 576];
    let (len, _) = timeout(Duration::from_secs(3), socket.recv_from(&mut buf))
        .await
        .map_err(|_| NetworkError::Timeout)?
        .map_err(|e| {
            NetworkError::NatTraversal(format!("Failed to receive STUN response: {}", e))
        })?;

    // Parse response
    let mapped_addr = parse_binding_response(&buf[..len], &transaction_id)?;

    Ok(StunResult {
        mapped_addr,
        local_addr,
    })
}
```

Add a unit test in the `#[cfg(test)] mod tests` block:

```rust
#[test]
fn test_stun_client_from_hostname_format() {
    // Verify that the STUN server constants have the expected host:port format
    assert!(GOOGLE_STUN.contains(':'));
    assert!(CLOUDFLARE_STUN.contains(':'));
}
```

**2. Add `--no-p2p` flag** to both `SendArgs` and `ReceiveArgs` in `crates/tallow/src/cli.rs`.

In `SendArgs` (after the `local` field):

```rust
/// Disable P2P direct connection (always use relay).
/// Automatically enabled when --tor or --proxy is active.
#[arg(long)]
pub no_p2p: bool,
```

In `ReceiveArgs` (after the `local` field):

```rust
/// Disable P2P direct connection (always use relay).
/// Automatically enabled when --tor or --proxy is active.
#[arg(long)]
pub no_p2p: bool,
```

Also add it to `ChatArgs`, `SyncArgs`, and `WatchArgs` if they have a relay connection flow. Check each struct -- if it has `--proxy` or `--tor` flags, it should also get `--no-p2p`.

  </action>
  <verify>
Run: `powershell.exe -NoProfile -Command "& { $env:LIB = 'C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0\um\x64;C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0\ucrt\x64;C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\lib\x64'; $env:INCLUDE = 'C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um;C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt;C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared;C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include'; $env:PATH = 'C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\bin\Hostx64\x64;' + $env:PATH; cargo build -p tallow 2>&1 }"` -- compile succeeds, `tallow send --help` shows `--no-p2p` flag.
  </verify>
  <done>
`StunClient::discover_from_port(port)` method binds STUN to a specific local port for NAT binding consistency. `--no-p2p` flag added to all relevant CLI command structs (SendArgs, ReceiveArgs, and any others with proxy/tor flags).
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p tallow-protocol -- messages` passes -- all message variants (old + new) round-trip correctly
2. `cargo test -p tallow-net -- candidates` passes -- encode/decode/validate tests pass
3. Existing `test_discriminant_stability_chat_end` test still reports ChatEnd = 28
4. New `test_discriminant_stability_p2p_variants` test confirms CandidateOffer/CandidatesDone/DirectConnected/DirectFailed have expected discriminants
5. `cargo build -p tallow` succeeds -- `--no-p2p` flag compiles on SendArgs and ReceiveArgs
6. `cargo clippy -p tallow-protocol -p tallow-net -p tallow -- -D warnings` clean
</verification>

<success_criteria>
- Four new P2P signaling Message variants exist and round-trip through postcard
- Postcard discriminant values for all pre-existing variants are unchanged
- `candidates.rs` provides `gather_candidates()`, `validate_candidate_addr()`, `encode_socket_addr()`, `decode_socket_addr()` with tests
- `StunClient::discover_from_port()` binds STUN to a specific port
- `--no-p2p` flag exists on SendArgs, ReceiveArgs (and any other args with proxy/tor)
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/20-webrtc-p2p-direct/20-01-SUMMARY.md`
</output>
