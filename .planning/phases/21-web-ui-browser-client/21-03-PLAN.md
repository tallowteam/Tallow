---
phase: 21-web-ui-browser-client
plan: 03
type: execute
wave: 2
depends_on: ["21-01", "21-02"]
files_modified:
  - crates/tallow-web/src/transport.rs
  - crates/tallow-web/src/transfer.rs
  - crates/tallow-web/src/file_io.rs
  - crates/tallow-web/src/lib.rs
  - web/index.html
  - web/style.css
  - web/app.ts
  - web/transfer.ts
autonomous: true
requirements:
  - WEB-07
  - WEB-08
  - WEB-09
  - WEB-10
  - WEB-11

must_haves:
  truths:
    - "A browser user can enter a code phrase and connect to the relay via WebSocket"
    - "The browser performs the full KEM handshake (HandshakeInit/Response/Kem/Complete) with a CLI peer"
    - "A browser user can drag-and-drop files to send, with progress bars showing speed and percentage"
    - "A browser user can receive files from a CLI peer with download triggered automatically"
    - "File chunks use 64KB size matching CLI, AES-256-GCM encryption runs in WASM, postcard encoding matches CLI wire format"
  artifacts:
    - path: "crates/tallow-web/src/transport.rs"
      provides: "WebSocket connection management via web-sys"
    - path: "crates/tallow-web/src/transfer.rs"
      provides: "Send/receive state machine — chunking, encryption, ACK handling"
    - path: "crates/tallow-web/src/file_io.rs"
      provides: "Browser File reading via Blob.slice(), download via Blob URL or StreamSaver"
    - path: "web/index.html"
      provides: "Main HTML page with code phrase form, drag-drop zone, progress display"
    - path: "web/app.ts"
      provides: "Application state machine, WASM initialization, WebSocket lifecycle"
    - path: "web/transfer.ts"
      provides: "File transfer UI logic — drag-drop, progress bars, send/receive orchestration"
  key_links:
    - from: "web/app.ts"
      to: "crates/tallow-web/src/lib.rs"
      via: "WASM module import (init, crypto, codec functions)"
      pattern: "import.*tallow_web"
    - from: "web/transfer.ts"
      to: "crates/tallow-web/src/crypto.rs"
      via: "encrypt_chunk / decrypt_chunk calls"
      pattern: "wasm\\.aes_gcm_encrypt|wasm\\.encrypt_chunk"
    - from: "web/app.ts"
      to: "crates/tallow-relay/src/websocket.rs"
      via: "WebSocket connection to relay WS endpoint"
      pattern: "new WebSocket.*wss?://"
---

<objective>
Build the browser file transfer UI and supporting WASM modules — WebSocket transport, file send/receive state machine, and the HTML/TypeScript frontend for code phrase entry, drag-and-drop file selection, and real-time transfer progress.

Purpose: This is the primary user-facing deliverable. A user visits the web app, enters a code phrase, and can send or receive files interoperably with the CLI. All encryption runs client-side in WASM.

Output: A working web application for file transfer with drag-and-drop, progress bars, and CLI interoperability.
</objective>

<execution_context>
@C:/Users/Aamir/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Aamir/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-web-ui-browser-client/21-RESEARCH.md
@.planning/phases/21-web-ui-browser-client/21-01-SUMMARY.md
@.planning/phases/21-web-ui-browser-client/21-02-SUMMARY.md

@crates/tallow-web/src/lib.rs
@crates/tallow-web/src/crypto.rs
@crates/tallow-web/src/codec.rs
@crates/tallow-protocol/src/wire/messages.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement WASM transport, file I/O, and transfer state machine</name>
  <files>
    crates/tallow-web/src/transport.rs
    crates/tallow-web/src/transfer.rs
    crates/tallow-web/src/file_io.rs
    crates/tallow-web/src/lib.rs
  </files>
  <action>
  **Step 1: Create transport.rs — WebSocket client via web-sys**

  Implement a `WsTransport` struct exposing wasm-bindgen methods:

  ```rust
  #[wasm_bindgen]
  pub struct WsTransport { /* web_sys::WebSocket */ }
  ```

  Methods:
  - `#[wasm_bindgen(constructor)] pub fn new(url: &str) -> Result<WsTransport, JsValue>` — Creates WebSocket, sets `binary_type = "arraybuffer"`. Does NOT wait for open (WebSocket connects async).
  - `pub fn send_bytes(&self, data: &[u8]) -> Result<(), JsValue>` — Sends raw bytes as binary WebSocket message. Uses `js_sys::Uint8Array::from(data)` then `ws.send_with_array_buffer()`.
  - `pub fn close(&self) -> Result<(), JsValue>` — Clean close.
  - `pub fn ready_state(&self) -> u16` — Returns WebSocket.readyState (0=CONNECTING, 1=OPEN, 2=CLOSING, 3=CLOSED).

  For receiving messages, use JS-side event listeners (not Rust callbacks — simpler architecture):
  - The TypeScript code sets `ws.onmessage` to route incoming binary messages to the appropriate handler.
  - The WASM module provides decode/process functions that TypeScript calls with the received bytes.

  Add `web-sys` features to Cargo.toml: `"WebSocket"`, `"MessageEvent"`, `"BinaryType"`, `"ErrorEvent"`, `"CloseEvent"`.

  **Step 2: Create file_io.rs — Browser file reading and download**

  File reading (for sending):
  - `pub async fn read_file_chunk(file: &web_sys::File, offset: f64, chunk_size: f64) -> Result<Vec<u8>, JsValue>` — Uses `file.slice_with_f64_and_f64()` to get a Blob, then `blob.array_buffer()` (returns Promise), await via wasm-bindgen-futures, convert to `Uint8Array` -> `Vec<u8>`.
  - Note: `File.size` returns `f64` in JavaScript (files can be >4GB). Use f64 for offset/size.

  File download (for receiving):
  - `pub fn trigger_download(data: &[u8], filename: &str) -> Result<(), JsValue>` — Creates a Blob from data, generates a Blob URL via `web_sys::Url::create_object_url_with_blob()`, creates an `<a>` element with `download` attribute, clicks it, revokes the URL.
  - For large files (>100MB), this buffers in memory. Note in a TODO comment that StreamSaver.js integration is a future optimization for streaming downloads. For v1, Blob URL download is acceptable.

  Add web-sys features: `"File"`, `"Blob"`, `"BlobPropertyBag"`, `"FileReader"`, `"Url"`, `"HtmlAnchorElement"`, `"Document"`, `"HtmlElement"`.

  **Step 3: Create transfer.rs — Send/receive state machine**

  This module orchestrates the handshake and file transfer protocol. Since the browser can be either sender or receiver, implement both paths:

  **Handshake (exposed to TypeScript as step-by-step functions):**
  The browser drives the handshake by calling WASM functions for each step, rather than having WASM manage the full async flow (simpler, avoids complex Future-in-WASM issues):

  1. `pub fn create_handshake_init(kem_capabilities: &[u8]) -> Result<HandshakeState, JsValue>` — Generates CPace keypair, random nonce, returns serialized HandshakeInit message + internal state for step 2.
  2. `pub fn process_handshake_response(state: &HandshakeState, response_bytes: &[u8]) -> Result<HandshakeKemState, JsValue>` — Processes HandshakeResponse, performs KEM encapsulation against peer's public key, derives session key, returns HandshakeKem message + session key material.
  3. `pub fn process_handshake_complete(state: &HandshakeKemState, complete_bytes: &[u8]) -> Result<Vec<u8>, JsValue>` — Verifies peer's key confirmation, returns final session key bytes.
  4. For the responder path: `create_handshake_response()`, `process_handshake_kem()`, `create_handshake_complete()`.

  **WasmSessionKey struct** (opaque to JS, holds derived key material):
  - Wraps the 32-byte AES-256-GCM key
  - Implements Zeroize/Drop
  - Used by encrypt/decrypt chunk functions

  **Sending:**
  - `pub fn prepare_file_offer(filename: &str, file_size: f64, session_key: &[u8]) -> Result<Vec<u8>, JsValue>` — Creates FileManifest, encrypts filename, returns encoded FileOffer message bytes.
  - `pub fn encrypt_and_encode_chunk(session_key: &[u8], transfer_id: &[u8], chunk_index: u64, total_chunks: Option<u64>, plaintext: &[u8]) -> Result<Vec<u8>, JsValue>` — Encrypts chunk with AES-256-GCM (counter nonce = chunk_index, AAD = transfer_id + chunk_index), encodes as Chunk message, returns postcard bytes.

  **Receiving:**
  - `pub fn decrypt_chunk(session_key: &[u8], transfer_id: &[u8], chunk_index: u64, ciphertext: &[u8]) -> Result<Vec<u8>, JsValue>` — Decrypts AES-256-GCM chunk, verifies AAD.
  - `pub fn verify_transfer_complete(expected_hash: &[u8], actual_hash: &[u8]) -> bool` — Constant-time comparison of BLAKE3 hashes.

  Update `crates/tallow-web/src/lib.rs` to declare new modules:
  ```rust
  pub mod transport;
  pub mod transfer;
  pub mod file_io;
  ```

  IMPORTANT: Look at how the CLI's send.rs and receive.rs construct FileManifest, build AAD for chunks, and handle the handshake flow. The browser must produce byte-identical encrypted chunks and manifest encodings. Cross-reference with `tallow-protocol/src/transfer/` and `tallow/src/commands/send.rs`.
  </action>
  <verify>
  `cargo check -p tallow-web` compiles. All public wasm-bindgen functions have valid signatures (no unsupported types). The encrypt_and_encode_chunk function produces the same Message::Chunk variant encoding as the CLI.
  </verify>
  <done>
  transport.rs wraps web-sys WebSocket for binary messaging. file_io.rs reads File chunks via Blob.slice() and triggers downloads via Blob URL. transfer.rs provides step-by-step handshake functions and chunk encrypt/decrypt that produce CLI-compatible wire format. All compile as part of tallow-web.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build the web frontend — HTML, CSS, and TypeScript application</name>
  <files>
    web/index.html
    web/style.css
    web/app.ts
    web/transfer.ts
  </files>
  <action>
  **Step 1: Create web/index.html**

  Single-page HTML with sections for each app state:
  1. **Landing/code phrase entry** — centered form with input field, "Send" and "Receive" buttons
  2. **Connecting** — spinner showing "Connecting to relay..."
  3. **Waiting for peer** — shows code phrase with copy button, "Waiting for peer to join..."
  4. **Handshake** — "Establishing secure connection..." with PQ crypto indicator
  5. **Send mode** — drag-and-drop zone, file list, "Send" button
  6. **Receive mode** — incoming file offer with accept/reject, file details (name, size)
  7. **Transfer in progress** — progress bar, speed (MB/s), percentage, ETA, file name
  8. **Complete** — success message with file hash verification checkmark
  9. **Error** — error message with retry button

  Structure:
  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Tallow — Secure File Transfer</title>
      <link rel="stylesheet" href="style.css">
  </head>
  <body>
      <main id="app">
          <header>
              <h1>Tallow</h1>
              <p class="subtitle">End-to-end encrypted file transfer</p>
          </header>

          <section id="landing" class="screen active">
              <!-- Code phrase input, Send/Receive mode selection -->
          </section>
          <section id="connecting" class="screen">...</section>
          <section id="waiting" class="screen">...</section>
          <section id="handshake" class="screen">...</section>
          <section id="send-mode" class="screen">
              <!-- Drag-and-drop zone -->
          </section>
          <section id="receive-mode" class="screen">...</section>
          <section id="transferring" class="screen">
              <!-- Progress bar, speed, ETA -->
          </section>
          <section id="complete" class="screen">...</section>
          <section id="error" class="screen">...</section>
      </main>
      <script type="module" src="app.ts"></script>
  </body>
  </html>
  ```

  The drag-and-drop zone in send mode should be a large dashed-border area that highlights on drag-over. Include a file input as fallback.

  The progress bar section should show: file name, progress bar (0-100%), transfer speed (e.g., "12.4 MB/s"), bytes transferred / total, ETA.

  Include a small footer: "All encryption runs in your browser. The server never sees your files." and a link to the GitHub repo.

  **Step 2: Create web/style.css**

  Clean, minimal CSS. Dark theme by default (matches terminal aesthetic), responsive:
  - Dark background (#1a1a2e or similar), light text
  - Monospace font for code phrase display
  - Card-style sections with subtle borders
  - Drag-and-drop zone: dashed border, highlight on dragover
  - Progress bar: custom styled (no browser defaults), animated fill
  - Responsive: works on mobile (320px) to desktop (1920px)
  - `.screen` sections: hidden by default, `.active` shows them
  - Transitions between screens (subtle opacity fade)
  - No external fonts or CDN dependencies

  **Step 3: Create web/app.ts — Main application logic**

  Application state machine that orchestrates WASM and WebSocket:

  ```typescript
  // State machine
  type AppState = 'landing' | 'connecting' | 'waiting' | 'handshake' | 'send-mode' | 'receive-mode' | 'transferring' | 'complete' | 'error';
  ```

  On page load:
  1. Load WASM module: `import init, * as wasm from './pkg/tallow_web.js'` (wasm-bindgen output)
  2. `await init()` — initializes WASM (panic hook, etc.)
  3. Show landing screen

  On "Send" button click with code phrase:
  1. Transition to 'connecting'
  2. Derive room ID: `wasm.blake3_hash(new TextEncoder().encode(codePhrase))` — 32-byte room hash
  3. Open WebSocket: `new WebSocket('wss://129.146.114.5:4434/ws')` (or configurable relay URL via `?relay=` URL parameter — MUST use `wss://` in production, `ws://` only for local dev)
  4. On WS open: send RoomJoin message (postcard-encoded via `wasm.encode_room_join(roomId, null)`)
  5. Wait for room join response
  6. If peer not present: transition to 'waiting'
  7. On peer arrival: transition to 'handshake', initiate handshake
  8. On handshake complete: transition to 'send-mode'

  On "Receive" button click with code phrase:
  1. Same connection flow
  2. If peer already present: transition to 'handshake' as responder
  3. On handshake complete: wait for FileOffer, transition to 'receive-mode'

  WebSocket message handler:
  - `ws.onmessage = async (event) => { const bytes = new Uint8Array(event.data); handle(bytes); }`
  - Parse message type via `wasm.decode_message(bytes)` (returns JS object with type discriminant)
  - Route to appropriate handler based on current state and message type

  Handshake flow (sender initiates):
  1. Sender: create HandshakeInit via WASM, send over WS
  2. Receiver: receive HandshakeInit, create HandshakeResponse via WASM, send
  3. Sender: receive HandshakeResponse, create HandshakeKem via WASM, send
  4. Receiver: receive HandshakeKem, create HandshakeComplete via WASM, send
  5. Both: session key established, transition to next state

  Error handling:
  - WebSocket close/error → show error screen with message and retry button
  - Handshake failure → show "Authentication failed. Check your code phrase." message
  - Transfer error → show error with details

  **Step 4: Create web/transfer.ts — File transfer UI logic**

  **Sending:**
  ```typescript
  async function sendFiles(files: FileList, ws: WebSocket, sessionKey: Uint8Array, transferId: Uint8Array) {
      const CHUNK_SIZE = 65536; // 64KB, matches CLI
      for (const file of files) {
          // Send FileOffer
          const offer = wasm.prepare_file_offer(file.name, file.size, sessionKey);
          ws.send(offer);

          // Wait for FileAccept
          const accepted = await waitForMessage('FileAccept');
          if (!accepted) return;

          // Send chunks with progress
          let offset = 0;
          let chunkIndex = 0;
          const totalChunks = Math.ceil(file.size / CHUNK_SIZE);

          while (offset < file.size) {
              const end = Math.min(offset + CHUNK_SIZE, file.size);
              const slice = file.slice(offset, end);
              const buffer = await slice.arrayBuffer();
              const plaintext = new Uint8Array(buffer);

              const total = (end >= file.size) ? totalChunks : null;
              const encrypted = wasm.encrypt_and_encode_chunk(
                  sessionKey, transferId, chunkIndex, total, plaintext
              );
              ws.send(encrypted);

              offset = end;
              chunkIndex++;
              updateProgress(chunkIndex, totalChunks, file.name, file.size);
          }
      }
  }
  ```

  **Receiving:**
  - Accumulate decrypted chunks in an array (or stream to download for large files)
  - On each Chunk: `wasm.decrypt_chunk(sessionKey, transferId, chunkIndex, ciphertext)` → store
  - Send Ack for each chunk: `ws.send(wasm.encode_ack(transferId, chunkIndex))`
  - On TransferComplete: verify hash, concatenate chunks, trigger download via `wasm.trigger_download(data, filename)`

  **Progress display:**
  - Update progress bar width as percentage
  - Calculate speed: track bytes transferred over time windows (last 2 seconds)
  - Display: "filename.txt — 45% — 12.4 MB/s — ETA: 0:23"
  - Update at least once per chunk (effectively once per ~64KB)

  **Drag-and-drop:**
  ```typescript
  const dropZone = document.getElementById('drop-zone');
  dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('drag-over'); });
  dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
  dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('drag-over');
      const files = e.dataTransfer.files;
      if (files.length > 0) handleFiles(files);
  });
  ```

  Also include a file input button as fallback: `<input type="file" multiple>`.

  **Sliding window:** For v1, send all chunks sequentially (wait for each ACK is too slow, fire-and-forget is simplest). The CLI uses window=8 but the browser can start simpler. Send chunks in bursts of 8, wait for ACKs, then send next 8. This matches the CLI's sliding window behavior.

  NOTE: TypeScript files are written as-is without a build system for now. The HTML loads them via `<script type="module">`. If TypeScript compilation is needed, document the `tsc` command. For v1, writing as plain JavaScript modules (`.js`) is acceptable if TypeScript tooling isn't available. Use JSDoc type annotations for type safety without a build step.

  NOTE: The WASM pkg/ directory will NOT exist until wasm-bindgen-cli processes the WASM output. To build the WASM module:
  1. `cargo install wasm-bindgen-cli` (if not already installed)
  2. `cargo build -p tallow-web --target wasm32-unknown-unknown --release`
  3. `wasm-bindgen target/wasm32-unknown-unknown/release/tallow_web.wasm --out-dir web/pkg --target web`
  The frontend JavaScript imports from `./pkg/tallow_web.js` which will only exist after step 3. This is expected — the WASM build pipeline is documented in Plan 21-05's BUILD.md.

  COMPLEXITY NOTE: This plan combines WASM state machine modules AND the complete frontend. This is acceptable because the WASM modules (transport, transfer, file_io) are thin wrappers and the frontend is a single HTML page with minimal JS. However, if quality issues arise during execution, the executor should prioritize the WASM modules (Task 1) and produce a minimal but functional frontend in Task 2, deferring UI polish to a gap closure plan.

  IMPORTANT: The relay URL must be configurable. Default to the deployed relay. Allow override via URL parameter: `?relay=wss://custom-relay.example.com/ws`.
  </action>
  <verify>
  1. `cargo check -p tallow-web` still passes with the new transport, transfer, file_io modules.
  2. Verify web files exist and are syntactically valid: check web/index.html is well-formed HTML (grep for `<!DOCTYPE html>`, `</html>` closing tag), web/style.css exists and is non-empty, web/app.ts and web/transfer.ts exist and are non-empty.
  3. Verify the WASM module import path is correct in app.ts: grep for `import.*tallow_web` or `import.*pkg/`.
  4. NOTE: Browser rendering is a manual post-execution check. Autonomous verify cannot open a browser. The executor should confirm file structure and syntax, not visual rendering.
  </verify>
  <done>
  Complete web frontend for file transfer: landing page with code phrase entry, WebSocket connection to relay, KEM handshake orchestration, drag-and-drop file sending with chunked encryption, file receiving with progressive download, real-time progress bars with speed/ETA. All crypto runs in WASM via tallow-web. Wire format is identical to CLI.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p tallow-web` compiles with transport, transfer, file_io modules
2. web/index.html loads in browser with all UI sections
3. Drag-and-drop zone activates on file drag
4. Progress bar renders with percentage, speed, ETA placeholders
5. TypeScript/JavaScript is syntactically valid
6. WASM module can be loaded and initialized from the web page
</verification>

<success_criteria>
- Browser user enters code phrase and connects to relay via WebSocket
- KEM handshake completes between browser and CLI peer using WASM crypto
- Files can be sent via drag-and-drop with 64KB chunked AES-256-GCM encryption
- Files can be received with progressive decryption and download
- Progress bars show real-time speed, percentage, and ETA
- Wire protocol is identical to CLI (browser-to-CLI interop works)
</success_criteria>

<output>
After completion, create `.planning/phases/21-web-ui-browser-client/21-03-SUMMARY.md`
</output>
