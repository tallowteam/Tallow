---
phase: 21-web-ui-browser-client
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/tallow-relay/Cargo.toml
  - crates/tallow-relay/src/websocket.rs
  - crates/tallow-relay/src/server.rs
  - crates/tallow-relay/src/main.rs
  - crates/tallow-relay/src/config.rs
autonomous: true
requirements:
  - WEB-04
  - WEB-05
  - WEB-06

must_haves:
  truths:
    - "Relay server accepts WebSocket connections on a configurable HTTP port alongside the existing QUIC listener"
    - "A browser WebSocket client can join a room and exchange postcard-encoded messages with a QUIC CLI peer"
    - "WebSocket-to-QUIC bridging adds/strips the 4-byte length prefix correctly"
    - "CORS headers are present on the WebSocket endpoint for cross-origin browser connections"
  artifacts:
    - path: "crates/tallow-relay/src/websocket.rs"
      provides: "WebSocket handler, WS-to-QUIC bridge, room integration"
      contains: "WebSocketUpgrade"
    - path: "crates/tallow-relay/src/server.rs"
      provides: "Dual QUIC + WebSocket listener startup"
      contains: "ws_router"
    - path: "crates/tallow-relay/src/config.rs"
      provides: "WebSocket bind address configuration"
      contains: "ws_bind_addr"
  key_links:
    - from: "crates/tallow-relay/src/websocket.rs"
      to: "crates/tallow-relay/src/room.rs"
      via: "shared RoomManager Arc"
      pattern: "room_manager"
    - from: "crates/tallow-relay/src/server.rs"
      to: "crates/tallow-relay/src/websocket.rs"
      via: "ws_router function call"
      pattern: "ws_router"
---

<objective>
Add WebSocket transport to the relay server for browser client connectivity.

Purpose: Browsers cannot speak QUIC directly (no WebTransport support in Safari). The relay must accept WebSocket connections alongside QUIC so browser clients can join rooms, perform handshakes, and exchange data with CLI peers. The relay bridges between transports transparently — the room system passes byte buffers regardless of whether they arrived via QUIC or WebSocket.

Output: The relay server runs dual listeners (QUIC on existing port + HTTP/WebSocket on a new port). Browser clients connect via WebSocket, join rooms, and interoperate with QUIC CLI peers.
</objective>

<execution_context>
@C:/Users/Aamir/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Aamir/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@crates/tallow-relay/Cargo.toml
@crates/tallow-relay/src/server.rs
@crates/tallow-relay/src/room.rs
@crates/tallow-relay/src/config.rs
@crates/tallow-relay/src/main.rs
@crates/tallow-relay/src/auth.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WebSocket dependencies and config, create WebSocket handler module</name>
  <files>
    crates/tallow-relay/Cargo.toml
    crates/tallow-relay/src/websocket.rs
    crates/tallow-relay/src/config.rs
    crates/tallow-relay/src/main.rs
  </files>
  <action>
    **Step 1: Add dependencies to tallow-relay/Cargo.toml:**
    ```toml
    # WebSocket transport (browser clients)
    axum = { version = "0.8", features = ["ws"] }
    tower = "0.5"
    tower-http = { version = "0.6", features = ["cors"] }
    futures = "0.3"
    ```
    Note: tokio is already a workspace dependency. `futures` may already be in workspace deps — check and use workspace version if available.

    **Step 2: Add WebSocket config to RelayConfig:**

    In `crates/tallow-relay/src/config.rs`, add to the config struct:
    ```rust
    /// WebSocket bind address (e.g., "0.0.0.0:4434")
    /// Set to empty string or omit to disable WebSocket listener
    pub ws_bind_addr: String,
    ```
    Default to `"0.0.0.0:4434"`. Also add the field to the TOML deserialization if using serde. Add to the `validate()` method — ensure ws_bind_addr parses as a valid SocketAddr when non-empty.

    **Step 3: Create `crates/tallow-relay/src/websocket.rs`:**

    This module handles all WebSocket connections. Structure:

    ```rust
    //! WebSocket transport for browser clients
    //!
    //! Runs an axum HTTP server that upgrades connections to WebSocket.
    //! Each WebSocket client joins the same room system as QUIC clients.
    //! The relay bridges message framing between transports.

    use axum::{
        extract::ws::{Message as WsMsg, WebSocket, WebSocketUpgrade},
        extract::State,
        routing::get,
        Router,
        response::IntoResponse,
    };
    use futures::{SinkExt, StreamExt};
    use std::sync::Arc;
    use tower_http::cors::{CorsLayer, Any};
    use tracing::{info, warn, debug};

    use crate::room::RoomManager;
    // ... auth, rate limiting imports as needed
    ```

    Key functions:

    1. **`ws_router(state: Arc<WsState>) -> Router`** — creates axum Router with:
       - `GET /ws` — WebSocket upgrade handler
       - `GET /health` — simple health check returning 200 (useful for monitoring)
       - CorsLayer middleware allowing all origins (browser clients from any domain)

    2. **`WsState`** struct containing:
       - `room_manager: Arc<RoomManager>`
       - `rate_limiter` reference (same as QUIC path)
       - `require_password: bool` + `password_hash: Option<[u8; 32]>` (from config, for auth)

    3. **`ws_handler(ws: WebSocketUpgrade, State(state): State<Arc<WsState>>) -> impl IntoResponse`** — accepts the upgrade and spawns `handle_ws_client`

    4. **`handle_ws_client(socket: WebSocket, state: Arc<WsState>)`** — the core handler:

       a. Read first binary message — this is the room join (RoomJoin or RoomJoinMulti), postcard-encoded, NO length prefix (WebSocket messages are already framed).

       b. Parse the first message using `postcard::from_bytes::<Message>()`. Validate it's a RoomJoin or RoomJoinMulti variant.

       c. Check relay password auth if required (same logic as QUIC path in server.rs — extract password_hash from message, compare with BLAKE3 using constant-time comparison via `subtle::ConstantTimeEq`).

       d. Join room via room_manager — same flow as QUIC path. For RoomJoin: get (PeerSender, PeerReceiver, peer_present). For RoomJoinMulti: get (peer_id, existing_peers, PeerSender, PeerReceiver).

       e. Send room joined response back via WebSocket (RoomJoined or RoomJoinedMulti, postcard-encoded, as binary WS message — NO length prefix).

       f. Split WebSocket with `socket.split()` into (ws_sink, ws_stream).

       g. **Bidirectional bridge with length prefix adaptation:**

          - **WS → Room (add length prefix):** Read binary WS messages. For each message, prepend a 4-byte big-endian length prefix (the raw postcard bytes length) before sending to the peer channel. This is because QUIC peers expect length-prefixed framing (TallowCodec). The peer channel carries `Vec<u8>` — prepend `(data.len() as u32).to_be_bytes()` then the data.

          - **Room → WS (strip length prefix):** Read from peer_rx channel. Each received `Vec<u8>` is a length-prefixed message from a QUIC peer. Strip the first 4 bytes (length prefix) and send the remaining bytes as a binary WebSocket message.

          CRITICAL: If BOTH peers are WebSocket clients (browser-to-browser), the room channels still carry the same format. The WS handler always adds length prefix on send-to-room and strips on receive-from-room. This works because:
          - WS peer A sends raw bytes → handler adds prefix → room channel → handler strips prefix → WS peer B receives raw bytes
          - QUIC peer sends prefixed bytes → room channel → handler strips prefix → WS peer receives raw bytes
          - WS peer sends raw bytes → handler adds prefix → room channel → QUIC peer receives prefixed bytes

          Wait — actually, the room system forwards raw bytes between peers. Check how the QUIC path works: in server.rs, does the QUIC handler strip the length prefix before putting data into the room channel, or does it forward the length-prefixed data? Read the existing server.rs code carefully.

          **If the room channels carry raw postcard bytes (no length prefix):** Then NO adaptation is needed — WS sends raw bytes, room carries raw bytes, WS receives raw bytes. QUIC path handles its own framing via TallowCodec.

          **If the room channels carry length-prefixed bytes:** Then WS handler must add/strip as described above.

          Read `crates/tallow-relay/src/server.rs` to determine which approach the current code uses. Then implement the correct bridging.

       h. Use `tokio::select!` to concurrently handle both directions. On any error or disconnect, clean up the room (remove peer).

    5. **Connection handling edge cases:**
       - Handle WebSocket close frames gracefully
       - Handle ping/pong (axum handles this automatically, but verify)
       - Timeout on initial room join (reuse HANDSHAKE_TIMEOUT = 10s)
       - Log connection events at appropriate tracing levels

    **Step 4: Wire into server.rs and main.rs:**

    In `server.rs`, add a `start_ws` method or modify `start()` to also spawn the WebSocket listener:
    ```rust
    // In start() or a new method:
    if !self.config.ws_bind_addr.is_empty() {
        let ws_state = Arc::new(WsState {
            room_manager: self.room_manager.clone(),
            // ... other fields
        });
        let ws_addr: SocketAddr = self.config.ws_bind_addr.parse()?;
        let app = crate::websocket::ws_router(ws_state);
        let listener = tokio::net::TcpListener::bind(ws_addr).await?;
        info!("WebSocket listener on {}", ws_addr);
        tokio::spawn(async move {
            axum::serve(listener, app).await.ok();
        });
    }
    ```

    The QUIC listener continues as before. Both listeners share the same `RoomManager` via `Arc`.

    In `main.rs`, add `mod websocket;` declaration.

    **CORS configuration:**
    ```rust
    let cors = CorsLayer::new()
        .allow_origin(Any)
        .allow_methods(Any)
        .allow_headers(Any);
    ```
    This is permissive because the relay is a data forwarding service — any browser origin should be able to connect. The security boundary is E2E encryption, not origin checking.
  </action>
  <verify>
    Run `cargo build -p tallow-relay` (via PowerShell wrapper). Run `cargo clippy -p tallow-relay -- -D warnings`. Run `cargo test -p tallow-relay` to verify existing tests still pass.
  </verify>
  <done>
    Relay server compiles with WebSocket support. The websocket.rs module handles WS connections, room joins, bidirectional message forwarding, and length prefix bridging. Config supports `ws_bind_addr`. CORS headers allow cross-origin connections. The QUIC listener is unchanged. WEB-04, WEB-05, WEB-06 satisfied.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add WebSocket handler tests and verify dual-transport startup</name>
  <files>
    crates/tallow-relay/src/websocket.rs
    crates/tallow-relay/src/server.rs
  </files>
  <action>
    Add unit tests in `websocket.rs` and integration-style tests:

    1. **Test: ws_router_creates_valid_router** — create a WsState, build the router, verify it doesn't panic.

    2. **Test: health_endpoint_returns_200** — use `axum::test` helpers (or construct a test request) to verify `/health` returns 200.

    3. **Test: room_join_via_ws** — simulate a WebSocket connection:
       - Create a RoomManager
       - Postcard-encode a `Message::RoomJoin { room_id, password_hash: None }`
       - Verify the message parses correctly in the handler logic
       - This can be a unit test of the parse logic extracted into a helper function

    4. **Test: length_prefix_add_strip_roundtrip** — if length prefix adaptation is used:
       - Take raw bytes `[0xDE, 0xAD]`
       - Add 4-byte BE prefix → `[0, 0, 0, 2, 0xDE, 0xAD]`
       - Strip prefix → `[0xDE, 0xAD]`
       - Assert roundtrip matches

    5. **Test: cors_headers_present** — verify the CORS layer adds `Access-Control-Allow-Origin: *` header.

    6. **Test: ws_state_shares_room_manager** — verify that WsState's room_manager Arc points to the same instance used by the QUIC path (structural test).

    For the dual-transport startup, verify in server.rs that when `ws_bind_addr` is non-empty, the WebSocket tokio::spawn is called. When `ws_bind_addr` is empty, only QUIC starts. Add a test or at least a code path that handles both cases.

    Also verify relay config defaults:
    - `ws_bind_addr` defaults to `"0.0.0.0:4434"`
    - QUIC continues on its existing default (4433)
    - Both parse as valid SocketAddr

    Ensure the relay's TOML config file (`relay.toml`) example is updated with the new `ws_bind_addr` field.
  </action>
  <verify>
    Run `cargo test -p tallow-relay` — all tests pass (old and new). Run `cargo clippy -p tallow-relay -- -D warnings` — no warnings.
  </verify>
  <done>
    WebSocket handler has tests for router creation, health endpoint, room join parsing, length prefix roundtrip, and CORS headers. Dual-transport startup is verified. Relay config includes ws_bind_addr with sensible default. All existing relay tests continue to pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p tallow-relay` succeeds with new WebSocket dependencies
2. `cargo test -p tallow-relay` passes all tests (old + new WS tests)
3. `cargo clippy -p tallow-relay -- -D warnings` clean
4. websocket.rs handles WS upgrade, room join, bidirectional forwarding
5. CORS headers present on WS endpoint (WEB-06)
6. Length prefix bridging correctly adapts between WS (no prefix) and QUIC (4-byte prefix) (WEB-05)
7. Config supports ws_bind_addr with default "0.0.0.0:4434" (WEB-04)
</verification>

<success_criteria>
- Relay accepts WebSocket connections alongside QUIC (WEB-04)
- WS-to-QUIC message bridging handles length prefix correctly (WEB-05)
- CORS headers allow cross-origin browser connections (WEB-06)
- All existing relay tests pass (backward compatibility)
</success_criteria>

<output>
After completion, create `.planning/phases/21-web-ui-browser-client/21-02-SUMMARY.md`
</output>
