---
phase: 21-web-ui-browser-client
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/tallow-relay/Cargo.toml
  - crates/tallow-relay/src/websocket.rs
  - crates/tallow-relay/src/server.rs
  - crates/tallow-relay/src/config.rs
  - crates/tallow-relay/src/main.rs
autonomous: true
requirements:
  - WEB-04
  - WEB-05
  - WEB-06

must_haves:
  truths:
    - "The relay server accepts WebSocket connections on a configurable port alongside QUIC"
    - "A WebSocket client can join a room, and messages are forwarded to QUIC peers and vice versa"
    - "WebSocket messages use raw postcard bytes (no length prefix); relay adds/strips 4-byte prefix when bridging to QUIC"
    - "CORS headers allow cross-origin WebSocket connections from the web UI"
    - "Rate limiting and password authentication apply equally to WebSocket and QUIC clients"
  artifacts:
    - path: "crates/tallow-relay/src/websocket.rs"
      provides: "axum WebSocket handler with room join, auth, bidirectional forwarding"
    - path: "crates/tallow-relay/src/server.rs"
      provides: "Dual-listener server (QUIC + WebSocket)"
    - path: "crates/tallow-relay/src/config.rs"
      provides: "ws_port and ws_enabled configuration fields"
  key_links:
    - from: "crates/tallow-relay/src/websocket.rs"
      to: "crates/tallow-relay/src/room.rs"
      via: "RoomManager::join_with_ip and get_peer_sender"
      pattern: "room_manager\\.join"
    - from: "crates/tallow-relay/src/server.rs"
      to: "crates/tallow-relay/src/websocket.rs"
      via: "spawns axum WS server alongside QUIC accept loop"
      pattern: "ws_router|axum::serve"
---

<objective>
Add WebSocket transport support to the relay server so browser clients can connect, join rooms, and exchange messages with QUIC-connected CLI peers.

Purpose: Browsers cannot speak QUIC directly (without WebTransport which has limited support). WebSocket is the universal browser transport. The relay must bridge WebSocket and QUIC clients transparently — the room system doesn't care about transport, only byte buffers.

Output: The relay server listens on two ports (QUIC and WebSocket), routing messages between them seamlessly.
</objective>

<execution_context>
@C:/Users/Aamir/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Aamir/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-web-ui-browser-client/21-RESEARCH.md

@crates/tallow-relay/src/server.rs
@crates/tallow-relay/src/room.rs
@crates/tallow-relay/src/config.rs
@crates/tallow-relay/src/main.rs
@crates/tallow-relay/src/auth.rs
@crates/tallow-relay/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WebSocket dependencies and configuration</name>
  <files>
    crates/tallow-relay/Cargo.toml
    crates/tallow-relay/src/config.rs
  </files>
  <action>
  **Step 1: Add dependencies to tallow-relay/Cargo.toml**

  Add these dependencies for WebSocket support:
  ```toml
  # WebSocket (browser transport)
  axum = { version = "0.8", features = ["ws"] }
  tower = "0.5"
  tower-http = { version = "0.6", features = ["cors"] }
  tokio-tungstenite = "0.26"
  futures-util = "0.3"
  ```

  Note: `axum` brings in `tokio` and `hyper` which are already compatible with the relay's tokio runtime. `futures-util` provides `SplitSink`/`SplitStream` for WebSocket.

  **Step 2: Update RelayConfig for WebSocket settings**

  In `crates/tallow-relay/src/config.rs`, add fields to `RelayConfig`:
  ```rust
  /// Enable WebSocket listener for browser clients
  pub ws_enabled: bool,
  /// WebSocket listener port (default: QUIC port + 1, e.g., 4434)
  pub ws_port: u16,
  /// Allowed CORS origins for WebSocket (e.g., ["https://web.tallow.app"])
  /// Empty = allow all origins (for development)
  pub ws_cors_origins: Vec<String>,
  ```

  Add defaults: `ws_enabled: true`, `ws_port: 4434`, `ws_cors_origins: vec![]`.

  If `RelayConfig` is parsed from TOML, add `#[serde(default)]` annotations so existing config files don't break.

  Also add corresponding CLI args if the relay uses clap. Look at `main.rs` for the existing CLI structure and add `--ws-port`, `--no-ws` flags.
  </action>
  <verify>
  `cargo check -p tallow-relay` compiles. Existing relay config parsing still works (no breaking changes to TOML format).
  </verify>
  <done>
  tallow-relay has axum + tower-http + tokio-tungstenite dependencies. RelayConfig has ws_enabled, ws_port, ws_cors_origins fields with sensible defaults. CLI flags added for WebSocket configuration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement WebSocket handler and dual-listener server</name>
  <files>
    crates/tallow-relay/src/websocket.rs
    crates/tallow-relay/src/server.rs
    crates/tallow-relay/src/main.rs
  </files>
  <action>
  **Step 1: Create websocket.rs — WebSocket handler**

  Create `crates/tallow-relay/src/websocket.rs` implementing the WebSocket-to-room bridge:

  1. **Router factory:**
     ```rust
     pub fn ws_router(room_manager: Arc<RoomManager>, rate_limiter: Arc<Mutex<RateLimiter>>, password: String, cors_origins: Vec<String>) -> Router
     ```
     Creates an axum Router with:
     - `GET /ws` — WebSocket upgrade endpoint
     - `GET /health` — Health check returning 200 OK (useful for load balancers)
     - CORS layer via `tower_http::cors::CorsLayer` — if `cors_origins` is empty, allow all; otherwise restrict to listed origins. Always allow `Content-Type` and standard headers.

  2. **WebSocket connection handler:**
     ```rust
     async fn handle_ws(socket: WebSocket, room_manager: Arc<RoomManager>, rate_limiter: Arc<Mutex<RateLimiter>>, password: String, remote_addr: Option<SocketAddr>)
     ```
     - Rate limit check on `remote_addr` IP (same logic as QUIC path)
     - Read first binary message (raw postcard bytes — NO length prefix)
     - Parse as RoomJoin or RoomJoinMulti using `parse_room_join_dispatch()` — REUSE the existing function from server.rs. Move `parse_room_join_dispatch` and related parsing functions to a shared location (e.g., a `parsing` module or keep in server.rs and make pub(crate)).
     - Verify password auth using `auth::verify_relay_password()` (same as QUIC)
     - Join room via `room_manager.join_with_ip()` or `room_manager.join_multi()` (same as QUIC)
     - Send RoomJoined/RoomJoinedMulti response as raw postcard bytes (NO length prefix)
     - Send PeerArrived notification to waiting peer (if applicable)

  3. **Bidirectional forwarding with length-prefix bridging:**
     Split WebSocket into sink + stream via `futures_util::StreamExt::split()`.

     **WS-to-peer direction (browser sends to CLI):**
     - Read binary WebSocket messages (raw postcard bytes)
     - Add 4-byte BE length prefix before forwarding to peer channel (QUIC peers expect length-prefixed messages)
     - Forward via `peer_tx.send(length_prefixed_data)`

     **Peer-to-WS direction (CLI sends to browser):**
     - Receive from `peer_rx` channel (data includes 4-byte length prefix from QUIC peer)
     - Strip the 4-byte length prefix before sending as WebSocket binary message
     - Send via `ws_sink.send(WsMsg::Binary(stripped_data))`

     CRITICAL: The length-prefix bridging is essential. QUIC uses byte streams with 4-byte BE length framing. WebSocket messages are already framed. The relay bridges between them:
     - Browser -> Relay (WS, no prefix) -> Relay adds prefix -> QUIC peer
     - QUIC peer -> Relay (with prefix) -> Relay strips prefix -> Browser (WS)

  4. **Multi-peer room support:**
     For `RoomJoinMulti`, the handler follows the same pattern as `handle_multi_connection()` in server.rs:
     - Route Targeted messages using `room.send_to()` or `room.broadcast_from()`
     - Overwrite `from_peer` for anti-spoofing
     - The inner postcard bytes in WS messages from browsers are identical to QUIC — just without the length prefix wrapper

  5. **Connection cleanup:**
     On WebSocket close or error:
     - Legacy rooms: `room_manager.peer_disconnected()`
     - Multi-peer rooms: `room_manager.multi_peer_disconnected()` + broadcast PeerLeftRoom

  **Step 2: Update server.rs — Spawn WebSocket alongside QUIC**

  Modify `RelayServer::start()` to:
  1. If `config.ws_enabled`, build the axum router via `ws_router()`
  2. Bind a `tokio::net::TcpListener` on `0.0.0.0:{ws_port}`
  3. Spawn `axum::serve(tcp_listener, router)` as a separate tokio task
  4. Log: `info!("WebSocket server listening on 0.0.0.0:{}", ws_port)`
  5. The QUIC accept loop continues as before — both listeners run concurrently

  The WebSocket server and QUIC server share the same `Arc<RoomManager>` and `Arc<Mutex<RateLimiter>>`. This is already thread-safe (RoomManager uses DashMap).

  Make `parse_room_join_dispatch()` and related helper functions `pub(crate)` so websocket.rs can reuse them. Also make `encode_room_joined()`, `encode_peer_arrived()`, `encode_auth_rejection()` pub(crate). Since WebSocket doesn't use length prefixes, also create `encode_room_joined_raw()` / `encode_peer_arrived_raw()` variants that return just the postcard payload bytes (no 4-byte prefix).

  **Step 3: Update main.rs**

  Add `mod websocket;` declaration. If the relay has CLI arg parsing in main.rs, wire the new `--ws-port` and `--no-ws` args to RelayConfig.

  **Testing notes:**
  Add a unit test in websocket.rs that verifies:
  - Length prefix is correctly added when forwarding WS->QUIC
  - Length prefix is correctly stripped when forwarding QUIC->WS
  - A room join message without length prefix is correctly parsed
  </action>
  <verify>
  `cargo check -p tallow-relay` compiles. `cargo test -p tallow-relay` passes (existing tests + new WebSocket bridging tests). The relay binary starts and logs both QUIC and WebSocket listener addresses.
  </verify>
  <done>
  websocket.rs implements full WebSocket handler: room join (legacy + multi-peer), password auth, rate limiting, bidirectional forwarding with length-prefix bridging. server.rs spawns both QUIC and WebSocket listeners sharing the same RoomManager. Browser clients can connect via `ws://relay:4434/ws` and communicate with QUIC CLI peers transparently.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p tallow-relay` compiles without errors
2. `cargo test -p tallow-relay` passes all tests (existing + new)
3. `cargo check --workspace` passes (no regressions)
4. The relay starts with both QUIC and WS listeners logged
5. WebSocket handler reuses room join parsing, auth, and rate limiting from QUIC path
6. Length-prefix bridging between WS (no prefix) and QUIC (4-byte prefix) is implemented and tested
</verification>

<success_criteria>
- Relay serves WebSocket on configurable port (default 4434) alongside QUIC (4433)
- WebSocket clients join rooms using the same RoomJoin message format
- Messages bridge transparently: WS (no prefix) <-> QUIC (length prefix)
- Auth, rate limiting, room cleanup apply to both transports
- CORS headers configured for cross-origin browser access
- Multi-peer room routing works for WebSocket clients
</success_criteria>

<output>
After completion, create `.planning/phases/21-web-ui-browser-client/21-02-SUMMARY.md`
</output>
