---
phase: 21-web-ui-browser-client
plan: 04
type: execute
wave: 3
depends_on: ["21-03"]
files_modified:
  - crates/tallow-web/src/clipboard.rs
  - crates/tallow-web/src/chat.rs
  - crates/tallow-web/src/lib.rs
  - web/clipboard.ts
  - web/chat.ts
  - web/index.html
  - web/style.css
autonomous: true
requirements:
  - WEB-12
  - WEB-13
  - WEB-14
  - WEB-15
  - WEB-16

must_haves:
  truths:
    - "Browser user can paste clipboard text and send it E2E encrypted to a CLI peer running `tallow clip`"
    - "Received clipboard text from CLI peer auto-copies to browser clipboard via Clipboard API"
    - "Browser user can send and receive E2E encrypted chat messages interoperable with `tallow chat`"
    - "Chat messages are sanitized via WASM-compiled sanitize_display() before rendering"
    - "Typing indicators are sent/received between browser and CLI chat peers"
    - "Chat history is stored in sessionStorage (not localStorage) and cleared on tab close"
  artifacts:
    - path: "crates/tallow-web/src/clipboard.rs"
      provides: "Clipboard content type detection, Message encoding for clipboard content"
    - path: "crates/tallow-web/src/chat.rs"
      provides: "Chat message encryption/decryption, sanitization, nonce management"
    - path: "web/clipboard.ts"
      provides: "Clipboard UI — paste button, auto-copy on receive, content preview"
    - path: "web/chat.ts"
      provides: "Chat UI — message list, input field, typing indicators, history"
  key_links:
    - from: "web/clipboard.ts"
      to: "crates/tallow-web/src/clipboard.rs"
      via: "WASM encode_clipboard_message / decode_clipboard_message"
      pattern: "wasm\\.encode_clipboard|wasm\\.detect_content_type"
    - from: "web/chat.ts"
      to: "crates/tallow-web/src/chat.rs"
      via: "WASM encrypt_chat_message / decrypt_chat_message / sanitize_display"
      pattern: "wasm\\.encrypt_chat|wasm\\.sanitize_display"
---

<objective>
Add browser clipboard sharing and encrypted chat UI — interoperable with the CLI's `tallow clip` and `tallow chat` commands. Clipboard integration reads/writes via the browser Clipboard API. Chat uses the same Message::ChatText wire format with AES-256-GCM encryption and WASM-compiled sanitization.

Purpose: These features make the browser client a full-featured peer, not just a file transfer tool. Clipboard sharing enables quick text/image transfer without files. Chat enables real-time communication during transfers. Both use the same E2E encryption and wire format as the CLI.

Output: Working clipboard sharing and chat features in the browser, interoperable with CLI peers.
</objective>

<execution_context>
@C:/Users/Aamir/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Aamir/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-web-ui-browser-client/21-RESEARCH.md
@.planning/phases/21-web-ui-browser-client/21-03-SUMMARY.md

@crates/tallow-web/src/lib.rs
@crates/tallow-web/src/crypto.rs
@crates/tallow-web/src/codec.rs
@crates/tallow-protocol/src/wire/messages.rs
@crates/tallow-protocol/src/transfer/sanitize.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement WASM clipboard and chat modules</name>
  <files>
    crates/tallow-web/src/clipboard.rs
    crates/tallow-web/src/chat.rs
    crates/tallow-web/src/lib.rs
  </files>
  <action>
  **Step 1: Create clipboard.rs — Clipboard content handling in WASM**

  Implement wasm-bindgen functions for clipboard content processing:

  1. **Content type detection:**
     - `pub fn detect_content_type(text: &str) -> String` — Returns "url", "code", "html", or "text" based on content analysis. URL detection: starts with `http://` or `https://`. Code detection: contains multiple newlines + common code patterns (brackets, semicolons, indentation). HTML: starts with `<` and contains `>`. Default: "text".
     - This should match the CLI's content type detection logic. Check `tallow-protocol/src/transfer/manifest.rs` or wherever TransferType is determined in the CLI.

  2. **Clipboard message encoding:**

     DETERMINED FROM clip.rs: The CLI's `tallow clip` uses the standard `SendPipeline` with `prepare_text(&payload)` + `chunk_data(&payload, 0)`. This means clipboard sends the same wire format as file transfer:
     - `Message::FileOffer { transfer_id, manifest }` — manifest is a serialized `FileManifest` created by `prepare_text()`
     - `Message::Chunk { transfer_id, index, total, data }` — encrypted chunk(s) of the clipboard content
     - `Message::TransferComplete { transfer_id, hash, merkle_root: None }` — completion with manifest hash
     There is NO special clipboard message variant. The clipboard IS a file transfer of a virtual text blob.

     Therefore, `encode_clipboard_message` should NOT create a custom message type. Instead, the browser clipboard flow should:
     1. Create a `FileManifest` matching `prepare_text()` output (single file named `_tallow_text_`, size = payload length)
     2. Encrypt the manifest and send as `Message::FileOffer`
     3. Chunk the payload at 64KB, encrypt each chunk with AES-256-GCM, send as `Message::Chunk`
     4. Send `Message::TransferComplete` with the manifest BLAKE3 hash

     The browser clipboard module should reuse the existing transfer.rs encrypt_and_encode_chunk() function rather than creating a parallel path. Provide a convenience wrapper:
     - `pub fn prepare_clipboard_offer(session_key: &[u8], transfer_id: &[u8], payload: &[u8]) -> Result<Vec<Vec<u8>>, JsValue>` — Returns a Vec of postcard-encoded messages (FileOffer + Chunks + TransferComplete) ready to send over WebSocket.

  3. **Clipboard image handling:**
     - `pub fn encode_clipboard_image(session_key: &[u8], transfer_id: &[u8], image_data: &[u8], mime_type: &str) -> Result<Vec<u8>, JsValue>` — Encrypts image blob data. Images from the browser Clipboard API come as PNG blobs.

  4. **Decoding received clipboard:**
     - `pub fn decode_clipboard_content(session_key: &[u8], transfer_id: &[u8], encrypted_data: &[u8]) -> Result<Vec<u8>, JsValue>` — Decrypts clipboard content received from peer.

  **Step 2: Create chat.rs — Chat message handling in WASM**

  Implement wasm-bindgen functions for E2E encrypted chat:

  1. **Chat message encryption:**
     - `pub fn encrypt_chat_message(session_key: &[u8], message_id: &[u8], sequence: u64, plaintext: &str) -> Result<Vec<u8>, JsValue>` — Encrypts plaintext with AES-256-GCM, builds the `Message::ChatText` variant with the encrypted ciphertext and 12-byte nonce, returns postcard-encoded bytes.

     DETERMINED FROM encrypt.rs: The CLI's chat nonce construction is:
     - 12-byte nonce: `[0u8; 4] || counter.to_be_bytes()` (first 4 bytes zero, last 8 bytes = counter as big-endian u64)
     - Counter increments by 2 after each message (even counters for sender, odd for receiver — prevents nonce collision)
     - AAD (additional authenticated data): `b"tallow-chat-v1"` (constant, not per-message)
     - The nonce is stored in `Message::ChatText.nonce` field (12 bytes) alongside the ciphertext

     The browser MUST use this exact construction:
     ```rust
     let mut nonce = [0u8; 12];
     nonce[4..12].copy_from_slice(&nonce_counter.to_be_bytes());
     // encrypt with AES-256-GCM using key=session_key, nonce=nonce, aad=b"tallow-chat-v1"
     *nonce_counter += 2; // even/odd split
     ```

     The browser sender should start with counter=0 (even) and the browser receiver should start with counter=1 (odd). This matches the CLI's convention in `tallow-protocol/src/chat/encrypt.rs`.

  2. **Chat message decryption:**
     - `pub fn decrypt_chat_message(session_key: &[u8], ciphertext: &[u8], nonce: &[u8]) -> Result<String, JsValue>` — Decrypts and returns UTF-8 plaintext.

  3. **Message sanitization:**
     - `pub fn sanitize_display(text: &str) -> String` — Calls the same sanitization logic as the CLI's `sanitize_display()`. This strips ANSI escape sequences, control characters, and limits length.

     Import from tallow-protocol if available via the `wasm` feature, OR reimplement the sanitization logic (it's typically: strip bytes 0x00-0x1F except \n and \t, strip ANSI CSI/OSC/DCS sequences, limit to 4096 chars).

     Check if `tallow_protocol::transfer::sanitize::sanitize_display` is available under the `wasm` feature. If tallow-protocol's wire module doesn't include sanitize, add it to the always-on modules, or copy the sanitization function into tallow-web/src/chat.rs (it's typically 20-30 lines of pure string processing).

  4. **Typing indicator encoding:**
     - `pub fn encode_typing_indicator(typing: bool) -> Result<Vec<u8>, JsValue>` — Encodes `Message::TypingIndicator { typing }` as postcard bytes.

  5. **Chat end encoding:**
     - `pub fn encode_chat_end() -> Result<Vec<u8>, JsValue>` — Encodes `Message::ChatEnd`.

  **Step 3: Update lib.rs**

  Add module declarations:
  ```rust
  pub mod clipboard;
  pub mod chat;
  ```
  </action>
  <verify>
  `cargo check -p tallow-web` compiles with all 7 modules (lib, crypto, codec, transport, transfer, file_io, clipboard, chat). Chat nonce construction matches CLI pattern. Sanitize function strips ANSI sequences correctly.
  </verify>
  <done>
  clipboard.rs provides content type detection, clipboard message encoding/decoding with AES-256-GCM encryption, image clipboard handling. chat.rs provides chat message encrypt/decrypt, sanitize_display, typing indicator encoding, chat end. All use the same wire format as the CLI.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build clipboard sharing and chat UI in the browser frontend</name>
  <files>
    web/clipboard.ts
    web/chat.ts
    web/index.html
    web/style.css
  </files>
  <action>
  **Step 1: Create web/clipboard.ts — Clipboard sharing UI**

  Implement clipboard sharing integrated into the main app:

  1. **Clipboard send (paste to share):**
     ```typescript
     async function sendClipboard() {
         try {
             const text = await navigator.clipboard.readText();
             if (!text) { showToast('Clipboard is empty'); return; }

             const contentType = wasm.detect_content_type(text);
             const encoded = new TextEncoder().encode(text);
             const encrypted = wasm.encode_clipboard_message(sessionKey, transferId, encoded);
             ws.send(encrypted);
             showToast(`Sent ${contentType}: ${text.substring(0, 50)}...`);
         } catch (err) {
             // Fallback: show paste textarea
             showPasteArea();
         }
     }
     ```

  2. **Clipboard receive (auto-copy):**
     ```typescript
     async function receiveClipboard(decrypted: Uint8Array) {
         const text = new TextDecoder().decode(decrypted);
         try {
             await navigator.clipboard.writeText(text);
             showToast('Copied to clipboard!');
         } catch {
             // Fallback: show text in a copyable field
             showCopyableText(text);
         }
         displayClipboardContent(text, wasm.detect_content_type(text));
     }
     ```

  3. **Image clipboard:**
     For reading images: `navigator.clipboard.read()` returns ClipboardItem with `image/png` blob. Read as ArrayBuffer, encrypt via WASM, send as clipboard image message.
     For writing images: Create `ClipboardItem` with `image/png` blob, write via `navigator.clipboard.write([item])`.
     NOTE: Image clipboard access requires HTTPS + user gesture + clipboard-read permission. Provide fallback if denied.

  4. **Clipboard content preview:**
     Show a small preview of sent/received clipboard content:
     - Text: first 100 chars with truncation
     - URL: clickable link
     - Image: thumbnail preview
     - Content type badge ("TEXT", "URL", "IMAGE", "CODE")

  **Step 2: Create web/chat.ts — Encrypted chat UI**

  Implement real-time chat:

  1. **Chat message list:**
     ```typescript
     class ChatUI {
         private messageList: HTMLElement;
         private input: HTMLInputElement;
         private sendButton: HTMLButtonElement;
         private history: ChatMessage[] = [];
         private sequence = 0;
         private peerSequence = 0;

         renderMessage(sender: 'me' | 'peer', text: string, timestamp: number) {
             const div = document.createElement('div');
             div.className = `message ${sender}`;
             div.innerHTML = `
                 <span class="sender">${sender === 'me' ? 'You' : 'Peer'}</span>
                 <span class="text">${escapeHtml(text)}</span>
                 <span class="time">${formatTime(timestamp)}</span>
             `;
             this.messageList.appendChild(div);
             this.messageList.scrollTop = this.messageList.scrollHeight;
         }
     }
     ```

  2. **Sending messages:**
     ```typescript
     async sendMessage(text: string) {
         if (!text.trim()) return;
         const messageId = wasm.random_bytes(16);
         const encrypted = wasm.encrypt_chat_message(sessionKey, messageId, this.sequence, text);
         ws.send(encrypted);
         this.renderMessage('me', text, Date.now());
         this.history.push({ sender: 'me', text, timestamp: Date.now() });
         this.sequence++;
         this.input.value = '';
     }
     ```

  3. **Receiving messages:**
     ```typescript
     receiveMessage(chatText: { ciphertext: Uint8Array, nonce: Uint8Array, sequence: number }) {
         const plaintext = wasm.decrypt_chat_message(sessionKey, chatText.ciphertext, chatText.nonce);
         const safe = wasm.sanitize_display(plaintext);
         this.renderMessage('peer', safe, Date.now());
         this.history.push({ sender: 'peer', text: safe, timestamp: Date.now() });
         this.peerSequence++;
     }
     ```

  4. **Typing indicators:**
     - On input focus/keypress: send `wasm.encode_typing_indicator(true)` (debounced, max once per 2 seconds)
     - On input blur or 3 seconds idle: send `wasm.encode_typing_indicator(false)`
     - On receive typing indicator: show/hide "Peer is typing..." below message list

  5. **Chat history:**
     - Store in `sessionStorage` as JSON (cleared on tab close, per research recommendations)
     - On session start: clear any stale history
     - NEVER use localStorage (plaintext persistence violates zero-knowledge design)

  6. **Chat end:**
     - On user clicking "End Chat" or closing tab: send `wasm.encode_chat_end()`
     - On receiving ChatEnd: show "Peer has left the chat" message, disable input

  **Step 3: Update web/index.html — Add clipboard and chat sections**

  Add new sections to the HTML:
  1. **Mode tabs** after handshake completes: "Files", "Clipboard", "Chat" — tab navigation to switch between modes while maintaining the same connection.

  2. **Clipboard section:**
     ```html
     <section id="clipboard-mode" class="screen">
         <div class="clipboard-actions">
             <button id="paste-send" class="btn primary">Share Clipboard</button>
             <button id="paste-image" class="btn secondary">Share Image</button>
         </div>
         <div id="clipboard-preview" class="preview-area">
             <!-- Shows preview of sent/received clipboard content -->
         </div>
         <textarea id="paste-fallback" class="hidden" placeholder="Paste here if clipboard access is denied"></textarea>
     </section>
     ```

  3. **Chat section:**
     ```html
     <section id="chat-mode" class="screen">
         <div id="chat-messages" class="message-list">
             <!-- Messages rendered here -->
         </div>
         <div id="typing-indicator" class="typing hidden">Peer is typing...</div>
         <div class="chat-input">
             <input type="text" id="chat-input" placeholder="Type a message..." maxlength="4096" autocomplete="off">
             <button id="chat-send" class="btn primary">Send</button>
         </div>
     </section>
     ```

  **Step 4: Update web/style.css — Clipboard and chat styles**

  Add styles for:
  - Tab navigation bar (Files | Clipboard | Chat)
  - Chat message list: scrollable container, message bubbles (sent right-aligned, received left-aligned)
  - Message bubble: sender name, text, timestamp
  - Typing indicator: subtle animated dots
  - Clipboard preview area: content type badge, truncated preview text
  - Clipboard actions: large buttons with icons
  - Paste fallback textarea: full-width, monospace
  </action>
  <verify>
  Open index.html in browser — clipboard and chat sections render correctly. Tab navigation switches between Files/Clipboard/Chat modes. Chat message input accepts text and Enter key. Typing indicator animation works. Clipboard "Share" button triggers clipboard read permission prompt. CSS is responsive on mobile.
  </verify>
  <done>
  Browser clipboard sharing: paste text/images to send via Clipboard API, auto-copy received content, content type detection, image preview. Browser chat: real-time message list, E2E encrypted via WASM, typing indicators, sanitized display, sessionStorage history. Both interoperable with CLI `tallow clip` and `tallow chat`. Tab navigation between Files/Clipboard/Chat modes.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p tallow-web` compiles with clipboard and chat modules
2. Chat nonce construction matches CLI exactly (cross-reference tallow-protocol/src/chat/)
3. sanitize_display strips ANSI sequences in WASM
4. Clipboard API access gated behind user gesture (button click)
5. Chat history uses sessionStorage, not localStorage
6. web/index.html renders all three mode tabs
7. Chat input sends on Enter key, typing indicator debounced to 2-second intervals
</verification>

<success_criteria>
- Browser clipboard "Share" button reads clipboard and sends encrypted content matching `tallow clip` wire format
- Received clipboard text auto-copies to browser clipboard
- Chat messages encrypt/decrypt correctly using AES-256-GCM with CLI-compatible nonces
- All received text sanitized via WASM sanitize_display() before rendering
- Typing indicators sent/received between browser and CLI
- Chat history stored in sessionStorage (cleared on tab close)
- Tab navigation switches between Files, Clipboard, and Chat modes
</success_criteria>

<output>
After completion, create `.planning/phases/21-web-ui-browser-client/21-04-SUMMARY.md`
</output>
