---
phase: 21-web-ui-browser-client
plan: 04
type: execute
wave: 3
depends_on:
  - 21-03
files_modified:
  - crates/tallow-web/src/lib.rs
  - crates/tallow-web/src/clipboard.rs
  - crates/tallow-web/src/chat.rs
  - web/clipboard.ts
  - web/chat.ts
  - web/app.ts
  - web/index.html
  - web/style.css
autonomous: true
requirements:
  - WEB-12
  - WEB-13
  - WEB-14
  - WEB-15
  - WEB-16

must_haves:
  truths:
    - "Browser can read clipboard text/images and send E2E encrypted, interoperable with tallow clip"
    - "Received clipboard content auto-copies to browser clipboard via Clipboard API"
    - "Browser chat sends/receives E2E encrypted messages interoperable with tallow chat"
    - "All received text is sanitized via sanitize_display before rendering"
    - "Typing indicators are sent/received between browser and CLI chat peers"
  artifacts:
    - path: "crates/tallow-web/src/clipboard.rs"
      provides: "Clipboard content type detection, encoding for wire protocol"
      contains: "#[wasm_bindgen]"
    - path: "crates/tallow-web/src/chat.rs"
      provides: "Chat message encryption/decryption with correct nonce construction"
      contains: "tallow-chat-v1"
    - path: "web/clipboard.ts"
      provides: "Clipboard API integration, paste-to-send, auto-copy-on-receive"
      contains: "navigator.clipboard"
    - path: "web/chat.ts"
      provides: "Chat UI, message list, input, typing indicators, emoji picker"
      contains: "chat-messages"
  key_links:
    - from: "web/clipboard.ts"
      to: "crates/tallow-web/src/clipboard.rs"
      via: "WASM function calls for content type detection and encryption"
      pattern: "wasm.*clipboard"
    - from: "web/chat.ts"
      to: "crates/tallow-web/src/chat.rs"
      via: "WASM function calls for message encryption/decryption"
      pattern: "wasm.*chat"
    - from: "web/chat.ts"
      to: "crates/tallow-web/src/codec.rs"
      via: "sanitize_display_text for received messages"
      pattern: "sanitize_display"
---

<objective>
Implement browser clipboard sharing and encrypted chat, both interoperable with CLI.

Purpose: These are the two remaining core features alongside file transfer. Clipboard sharing lets users paste text/images in the browser and have them appear on the CLI peer's clipboard (and vice versa). Chat provides real-time E2E encrypted messaging using the same wire protocol as `tallow chat`. Both features use the session key from the KEM handshake established in Plan 03.

Output: Working clipboard sharing and chat in the browser, interoperable with CLI peers.
</objective>

<execution_context>
@C:/Users/Aamir/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Aamir/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-web-ui-browser-client/21-03-SUMMARY.md
@.planning/phases/21-web-ui-browser-client/21-CONTEXT.md
@crates/tallow-web/src/crypto.rs
@crates/tallow-web/src/codec.rs
@crates/tallow-protocol/src/wire/messages.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: WASM clipboard and chat modules + TypeScript Clipboard API integration</name>
  <files>
    crates/tallow-web/src/lib.rs
    crates/tallow-web/src/clipboard.rs
    crates/tallow-web/src/chat.rs
    web/clipboard.ts
  </files>
  <action>
    **clipboard.rs — WASM clipboard helpers:**

    The CLI `tallow clip` sends clipboard content as a FileOffer with a special manifest (content type, data as a single "file"). The browser must use the SAME wire format for interop.

    Read `crates/tallow/src/commands/clip.rs` or the clipboard module to understand exactly how `tallow clip` encodes clipboard content. It likely:
    1. Detects content type (text, URL, image, code)
    2. Wraps content as a FileOffer with manifest containing type metadata
    3. Sends the data as encrypted Chunks (same pipeline as file transfer)

    Implement in clipboard.rs:

    1. `detect_content_type(text: &str) -> String` — returns "url", "code", "text" based on heuristics (starts with http(s)://, contains code patterns, or plain text). Export via wasm-bindgen.

    2. `prepare_clipboard_manifest(content_type: &str, data_size: u64) -> Result<Vec<u8>, JsValue>` — builds a manifest compatible with CLI's clip format. This needs to match exactly what the CLI generates.

    3. `parse_clipboard_content(manifest_bytes: &[u8]) -> Result<JsValue, JsValue>` — decode manifest to determine if this is a clipboard transfer vs regular file transfer. Return {is_clipboard: bool, content_type: string, size: u64}.

    Update `lib.rs` to add `pub mod clipboard; pub mod chat;`

    **chat.rs — Chat message encryption with correct nonce construction:**

    Per WEB-14 requirement: AES-256-GCM with nonce `[0u8;4]||counter.to_be_bytes()`, AAD `b"tallow-chat-v1"`, counter increments by 2.

    1. `ChatSession` struct (wasm-bindgen exported):
       - `new(session_key: &[u8]) -> Result<ChatSession, JsValue>` — validate key is 32 bytes
       - `encrypt_message(text: &str) -> Result<Vec<u8>, JsValue>` — encrypt text, increment send counter by 2, return encrypted bytes with nonce
       - `decrypt_message(ciphertext: &[u8], nonce: &[u8]) -> Result<String, JsValue>` — decrypt, increment receive counter by 2, return plaintext
       - `prepare_chat_text(message_id: &[u8], sequence: u64, ciphertext: &[u8], nonce: &[u8]) -> Result<Vec<u8>, JsValue>` — encode as Message::ChatText
       - `prepare_typing_indicator(typing: bool) -> Result<Vec<u8>, JsValue>` — encode as Message::TypingIndicator
       - `send_counter(&self) -> u64`
       - `receive_counter(&self) -> u64`

    CRITICAL nonce construction (must match CLI exactly):
    ```rust
    fn build_nonce(counter: u64) -> [u8; 12] {
        let mut nonce = [0u8; 12];
        // First 4 bytes: zero
        // Last 8 bytes: counter as big-endian
        nonce[4..12].copy_from_slice(&counter.to_be_bytes());
        nonce
    }
    ```
    AAD is always `b"tallow-chat-v1"`.

    Verify this matches the CLI implementation in `crates/tallow/src/commands/chat.rs` or wherever chat encryption is done.

    **web/clipboard.ts:**

    1. **Reading clipboard (sending):**
       ```typescript
       async function shareClipboard() {
           // Requires user gesture (button click handler)
           try {
               const text = await navigator.clipboard.readText();
               if (text) {
                   const contentType = wasm.detect_content_type(text);
                   // Encode as file transfer (same pipeline as file send)
                   const data = new TextEncoder().encode(text);
                   const manifest = wasm.prepare_clipboard_manifest(contentType, data.length);
                   // Send FileOffer with manifest
                   // Then send data as encrypted Chunks (single chunk for small text)
                   // ...
                   showNotification(`Clipboard sent (${contentType})`);
               }
           } catch (err) {
               // Clipboard API denied — show fallback textarea
               showClipboardFallback();
           }
       }
       ```

    2. **Reading images from clipboard:**
       ```typescript
       async function shareClipboardImage() {
           const items = await navigator.clipboard.read();
           for (const item of items) {
               if (item.types.includes('image/png')) {
                   const blob = await item.getType('image/png');
                   const buffer = await blob.arrayBuffer();
                   // Send as clipboard transfer with image content type
                   // ...
               }
           }
       }
       ```

    3. **Writing clipboard (receiving):**
       ```typescript
       async function receiveClipboard(decryptedData: Uint8Array, contentType: string) {
           if (contentType === 'text' || contentType === 'url' || contentType === 'code') {
               const text = new TextDecoder().decode(decryptedData);
               await navigator.clipboard.writeText(text);
               showNotification('Clipboard received and copied!');
           } else if (contentType.startsWith('image/')) {
               const blob = new Blob([decryptedData], { type: 'image/png' });
               const item = new ClipboardItem({ 'image/png': blob });
               await navigator.clipboard.write([item]);
               showNotification('Image received and copied to clipboard!');
           }
       }
       ```

    4. **Fallback:** If Clipboard API is denied, show a textarea where user can Ctrl+V paste. On paste event, read the content and send.

    5. **Clipboard status display:** Show in the clipboard panel: "Last shared: 3 seconds ago (text, 142 bytes)" or "Waiting for clipboard content from peer..."
  </action>
  <verify>
    Run `cargo build -p tallow-web --target wasm32-unknown-unknown --release`. Verify clipboard.rs and chat.rs compile. Check that clipboard.ts and chat nonce construction match CLI implementations.
  </verify>
  <done>
    WASM clipboard module detects content types and prepares manifests compatible with CLI clip format. WASM chat module encrypts/decrypts messages with correct nonce construction ([0u8;4]||counter.to_be_bytes(), AAD b"tallow-chat-v1", counter increments by 2). TypeScript clipboard integration reads/writes via Clipboard API with fallback textarea.
  </done>
</task>

<task type="auto">
  <name>Task 2: Chat UI with real-time messaging, typing indicators, sanitization, and emoji</name>
  <files>
    web/chat.ts
    web/app.ts
    web/index.html
    web/style.css
  </files>
  <action>
    **web/chat.ts:**

    Complete chat UI implementation:

    1. **ChatUI class:**
       ```typescript
       class ChatUI {
           private messages: ChatMessage[] = [];
           private chatSession: WasmChatSession;
           private typingTimer: number | null = null;

           constructor(sessionKey: Uint8Array) {
               this.chatSession = new wasm.ChatSession(sessionKey);
           }

           async sendMessage(text: string) {
               if (!text.trim()) return;

               // Encrypt via WASM
               const encrypted = this.chatSession.encrypt_message(text);
               const messageId = crypto.getRandomValues(new Uint8Array(16));
               const sequence = this.chatSession.send_counter();

               // Build nonce from counter
               const nonce = new Uint8Array(12);
               const counterBytes = new DataView(new ArrayBuffer(8));
               counterBytes.setBigUint64(0, BigInt(sequence));
               nonce.set(new Uint8Array(counterBytes.buffer), 4);

               // Encode as ChatText
               const msgBytes = this.chatSession.prepare_chat_text(
                   messageId, sequence, encrypted, nonce
               );
               ws.send(msgBytes);

               // Add to local display
               this.addMessage('me', text, Date.now());
               this.clearInput();
           }

           receiveMessage(data: Uint8Array) {
               // Decode message to get ciphertext + nonce
               const decoded = wasm.decode_message(data);
               if (decoded.type !== 'ChatText') return;

               // Decrypt via WASM
               const plaintext = this.chatSession.decrypt_message(
                   decoded.ciphertext, decoded.nonce
               );

               // Sanitize via WASM (WEB-15)
               const safe = wasm.sanitize_display_text(plaintext);

               this.addMessage('peer', safe, Date.now());
           }

           private addMessage(sender: string, text: string, timestamp: number) {
               this.messages.push({ sender, text, timestamp });
               this.renderMessages();
               this.scrollToBottom();
               // Store in sessionStorage (NOT localStorage — WEB-14 security)
               sessionStorage.setItem('chat-history', JSON.stringify(this.messages));
           }

           private renderMessages() {
               const container = document.getElementById('chat-messages')!;
               container.innerHTML = this.messages.map(msg => `
                   <div class="chat-msg ${msg.sender === 'me' ? 'msg-mine' : 'msg-peer'}">
                       <span class="msg-text">${escapeHtml(msg.text)}</span>
                       <span class="msg-time">${formatTime(msg.timestamp)}</span>
                   </div>
               `).join('');
           }
       }
       ```

    2. **Typing indicators (WEB-16):**
       - On keypress in chat input: debounce 300ms, then send `TypingIndicator { typing: true }` via WASM encode
       - On 2 seconds of no typing: send `TypingIndicator { typing: false }`
       - On receiving typing indicator: show "Peer is typing..." below the message list with a subtle animation (three animated dots)
       - Clear typing indicator when a message is received from the peer

    3. **Emoji support (user decision: native emoji picker + text):**
       - The emoji button (#btn-emoji) opens the browser's native emoji picker if available
       - If the browser supports `window.showPicker()` on an input, use it
       - Fallback: a simple emoji grid overlay with common emojis (smileys, hands, hearts — ~50 emojis)
       - Emojis are just Unicode characters — they go through the same encrypt/decrypt path as regular text

    4. **Chat message sanitization (WEB-15):**
       - ALL received text passes through `wasm.sanitize_display_text()` before rendering
       - Additionally, in the TypeScript render: use `escapeHtml()` to prevent XSS:
         ```typescript
         function escapeHtml(text: string): string {
             const div = document.createElement('div');
             div.textContent = text;
             return div.innerHTML;
         }
         ```
       - This double-sanitization (WASM strips ANSI/control chars, TS escapes HTML) ensures safety

    5. **Chat history:**
       - Store in `sessionStorage` (cleared on tab close — per research pitfall 9)
       - On session start: load existing history from sessionStorage if resuming
       - On session end: explicitly clear with `sessionStorage.removeItem('chat-history')`
       - Never write decrypted messages to localStorage or IndexedDB

    6. **Message display:**
       - Messages from "me" aligned right with accent color background
       - Messages from "peer" aligned left with secondary background
       - Timestamps in subtle muted color
       - Auto-scroll to bottom on new messages
       - Scrollable container with max-height

    **Update web/app.ts:**

    Wire chat and clipboard into the main app state machine:
    - After handshake completes (state = 'dashboard'), instantiate ChatUI and clipboard handlers
    - Route incoming WebSocket messages: check decoded message type, dispatch to chat.receiveMessage(), clipboard handler, or transfer handler
    - Add keyboard shortcuts: Enter in chat input sends message

    **Update web/index.html and web/style.css:**

    - Chat message styling: bubbles with border-radius, alternating alignment
    - Typing indicator: "..." animation below messages
    - Emoji button styling
    - Clipboard panel: "Share Clipboard" button, status text, received content display
    - Transitions: messages slide in, typing indicator fades in/out
  </action>
  <verify>
    Build WASM and open web UI in browser. Verify: (1) Chat input accepts text and displays sent messages, (2) Emoji button shows picker, (3) Typing indicator appears when typing, (4) Clipboard share button triggers Clipboard API (may need user gesture), (5) All text is HTML-escaped in chat. Test with a CLI peer if relay is available.
  </verify>
  <done>
    Chat UI renders messages with proper styling, typing indicators, and emoji support. All received text sanitized via WASM sanitize_display + HTML escaping. Chat history stored in sessionStorage only. Clipboard sharing reads/writes via Clipboard API with fallback. Typing indicators sent/received with debouncing. WEB-12, WEB-13, WEB-14, WEB-15, WEB-16 satisfied.
  </done>
</task>

</tasks>

<verification>
1. Clipboard text sharing: paste text, send encrypted, peer receives and auto-copies (WEB-12, WEB-13)
2. Clipboard image sharing: paste image, send encrypted, peer receives (WEB-12)
3. Chat message encryption uses correct nonce [0u8;4]||counter.to_be_bytes() and AAD b"tallow-chat-v1" (WEB-14)
4. All received text passes through sanitize_display_text() before rendering (WEB-15)
5. HTML escaping prevents XSS on displayed messages
6. Typing indicators debounced and displayed correctly (WEB-16)
7. Chat history in sessionStorage, NOT localStorage
8. Emoji picker works (native or fallback grid)
9. Clipboard fallback textarea works when API is denied
</verification>

<success_criteria>
- Browser clipboard sharing sends E2E encrypted, interoperable with tallow clip (WEB-12)
- Received clipboard auto-copies via Clipboard API (WEB-13)
- Chat E2E encrypted with correct nonce/AAD, interoperable with tallow chat (WEB-14)
- All text sanitized before display (WEB-15)
- Typing indicators work bidirectionally (WEB-16)
</success_criteria>

<output>
After completion, create `.planning/phases/21-web-ui-browser-client/21-04-SUMMARY.md`
</output>
