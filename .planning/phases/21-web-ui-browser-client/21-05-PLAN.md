---
phase: 21-web-ui-browser-client
plan: 05
type: execute
wave: 4
depends_on: ["21-04"]
files_modified:
  - web/worker.ts
  - web/manifest.json
  - web/index.html
  - crates/tallow-web/src/lib.rs
  - crates/tallow-web/tests/wasm_crypto.rs
  - crates/tallow-relay/src/websocket.rs
autonomous: true
requirements:
  - WEB-17
  - WEB-18

must_haves:
  truths:
    - "The web app can be installed as a PWA (Add to Home Screen) with offline shell capability"
    - "WASM crypto produces identical output to native for KEM, AES-GCM, and BLAKE3"
    - "WebSocket relay forwarding works bidirectionally between WS and QUIC clients"
    - "The web app loads and initializes on HTTPS without mixed content errors"
  artifacts:
    - path: "web/manifest.json"
      provides: "PWA manifest with app name, icons, theme"
    - path: "web/worker.ts"
      provides: "Service worker for PWA offline shell caching"
    - path: "crates/tallow-web/tests/wasm_crypto.rs"
      provides: "Tests verifying WASM crypto matches native output"
  key_links:
    - from: "web/index.html"
      to: "web/manifest.json"
      via: "link rel=manifest"
      pattern: "rel=\"manifest\""
    - from: "web/index.html"
      to: "web/worker.ts"
      via: "navigator.serviceWorker.register"
      pattern: "serviceWorker\\.register"
---

<objective>
Add Progressive Web App capability, verify WASM crypto correctness via tests, and finalize deployment configuration. The web app should be installable, work offline (shell), and have verified cryptographic interoperability with the CLI.

Purpose: PWA capability means users can "install" Tallow without an app store. Testing ensures the browser client's WASM crypto produces identical results to the native CLI — the foundation of the interoperability guarantee.

Output: Installable PWA, verified WASM crypto tests, deployment-ready web application.
</objective>

<execution_context>
@C:/Users/Aamir/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Aamir/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-web-ui-browser-client/21-RESEARCH.md
@.planning/phases/21-web-ui-browser-client/21-04-SUMMARY.md

@crates/tallow-web/src/lib.rs
@crates/tallow-web/src/crypto.rs
@web/index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: PWA manifest, service worker, and deployment configuration</name>
  <files>
    web/manifest.json
    web/worker.ts
    web/index.html
  </files>
  <action>
  **Step 1: Create web/manifest.json — PWA manifest**

  ```json
  {
      "name": "Tallow — Secure File Transfer",
      "short_name": "Tallow",
      "description": "End-to-end encrypted file transfer with post-quantum cryptography. No install needed.",
      "start_url": "/",
      "display": "standalone",
      "background_color": "#1a1a2e",
      "theme_color": "#e94560",
      "orientation": "any",
      "icons": [
          {
              "src": "/icons/icon-192.png",
              "sizes": "192x192",
              "type": "image/png"
          },
          {
              "src": "/icons/icon-512.png",
              "sizes": "512x512",
              "type": "image/png"
          }
      ],
      "categories": ["utilities", "security"]
  }
  ```

  NOTE: Icons are placeholders. For v1, create simple SVG icons (a candle/flame for "tallow") or use placeholder solid-color PNGs. The icons directory should be `web/icons/`.

  Create simple placeholder icon files:
  - `web/icons/icon-192.png` — 192x192 placeholder (can be a simple colored square with "T" letter)
  - `web/icons/icon-512.png` — 512x512 placeholder

  For v1, use a minimal inline SVG approach or generate PNGs from an SVG. A simple approach: create an SVG in the HTML and reference it, or create minimal PNG files via a canvas script.

  **Step 2: Create web/worker.ts — Service worker**

  Minimal service worker for PWA install capability and offline shell caching:

  ```typescript
  const CACHE_NAME = 'tallow-v1';
  const SHELL_FILES = [
      '/',
      '/index.html',
      '/style.css',
      '/app.js',
      '/transfer.js',
      '/clipboard.js',
      '/chat.js',
      '/pkg/tallow_web_bg.wasm',
      '/pkg/tallow_web.js',
      '/manifest.json'
  ];

  self.addEventListener('install', (event: ExtendableEvent) => {
      event.waitUntil(
          caches.open(CACHE_NAME).then(cache => cache.addAll(SHELL_FILES))
      );
  });

  self.addEventListener('fetch', (event: FetchEvent) => {
      // Cache-first for shell files, network-first for API/WebSocket
      if (event.request.url.includes('/ws') || event.request.url.includes('wss://')) {
          return; // Don't cache WebSocket requests
      }
      event.respondWith(
          caches.match(event.request).then(cached => cached || fetch(event.request))
      );
  });

  self.addEventListener('activate', (event: ExtendableEvent) => {
      // Clean old caches
      event.waitUntil(
          caches.keys().then(keys =>
              Promise.all(keys.filter(k => k !== CACHE_NAME).map(k => caches.delete(k)))
          )
      );
  });
  ```

  This provides:
  - Offline shell capability (HTML/CSS/JS/WASM cached)
  - Cache versioning (bump CACHE_NAME on deploy)
  - WebSocket requests are not cached (network-only)

  **Step 3: Update web/index.html — PWA integration**

  Add to `<head>`:
  ```html
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#e94560">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  ```

  Add service worker registration at the bottom of `<body>` (after main script):
  ```html
  <script>
      if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('worker.js')
              .then(reg => console.log('SW registered:', reg.scope))
              .catch(err => console.warn('SW registration failed:', err));
      }
  </script>
  ```

  **Step 4: Build instructions documentation**

  Add a `web/BUILD.md` (not a general readme, just build instructions) with:
  1. How to build the WASM module:
     ```bash
     # Install wasm-bindgen CLI
     cargo install wasm-bindgen-cli

     # Build WASM
     cargo build -p tallow-web --target wasm32-unknown-unknown --release

     # Generate JS bindings
     wasm-bindgen target/wasm32-unknown-unknown/release/tallow_web.wasm --out-dir web/pkg --target web

     # Optimize (optional, ~20-40% size reduction)
     wasm-opt -Oz web/pkg/tallow_web_bg.wasm -o web/pkg/tallow_web_bg.wasm
     ```

  2. How to serve locally for development:
     ```bash
     # Any static file server works
     cd web && python -m http.server 8080
     # Open https://localhost:8080 (HTTPS needed for Clipboard API, use mkcert for local certs)
     ```

  3. Deployment: static files go to any CDN/hosting (GitHub Pages, Vercel, Netlify). The WASM file is served alongside HTML/CSS/JS.

  4. Relay configuration: Set `?relay=wss://your-relay:4434/ws` in URL or update default in app.ts.
  </action>
  <verify>
  web/manifest.json is valid JSON. Service worker JavaScript is syntactically valid. index.html includes manifest link and service worker registration. Build instructions in web/BUILD.md are accurate.
  </verify>
  <done>
  PWA manifest with app metadata and placeholder icons. Service worker caches shell files for offline install capability. index.html has PWA meta tags and SW registration. Build instructions document WASM compilation and local development setup.
  </done>
</task>

<task type="auto">
  <name>Task 2: WASM crypto verification tests and relay WebSocket tests</name>
  <files>
    crates/tallow-web/tests/wasm_crypto.rs
    crates/tallow-relay/src/websocket.rs
  </files>
  <action>
  **Step 1: Create WASM crypto correctness tests**

  Create `crates/tallow-web/tests/wasm_crypto.rs` with tests that verify WASM-compiled crypto produces identical output to native. These run as standard `cargo test` (on native target — testing the same code paths that will run in WASM):

  1. **BLAKE3 hash consistency:**
     ```rust
     #[test]
     fn test_blake3_consistent() {
         let data = b"test data for hashing";
         let web_hash = tallow_web::crypto::blake3_hash(data);
         let native_hash = blake3::hash(data);
         assert_eq!(web_hash, native_hash.as_bytes());
     }
     ```

  2. **AES-256-GCM encrypt/decrypt round-trip:**
     ```rust
     #[test]
     fn test_aes_gcm_roundtrip() {
         let key = [0x42u8; 32];
         let plaintext = b"secret message for encryption test";
         let aad = b"additional data";
         let nonce_counter = 42u64;

         let ciphertext = tallow_web::crypto::aes_gcm_encrypt(&key, nonce_counter, aad, plaintext).unwrap();
         let decrypted = tallow_web::crypto::aes_gcm_decrypt(&key, nonce_counter, aad, &ciphertext).unwrap();
         assert_eq!(decrypted, plaintext);
     }
     ```

  3. **AES-256-GCM cross-compatibility (WASM wrapper vs direct tallow-crypto):**
     ```rust
     #[test]
     fn test_aes_gcm_cross_compat() {
         // Encrypt with tallow-web wrapper
         let key = [0xAB; 32];
         let plaintext = b"cross-compatibility test";
         let aad = b"test-aad";
         let nonce = 7u64;

         let web_ct = tallow_web::crypto::aes_gcm_encrypt(&key, nonce, aad, plaintext).unwrap();

         // Decrypt with direct tallow-crypto call
         let native_pt = tallow_crypto::symmetric::/* decrypt function */(&key, nonce, aad, &web_ct).unwrap();
         assert_eq!(&native_pt, plaintext);
     }
     ```

  4. **Hybrid KEM generate + encapsulate + decapsulate round-trip:**
     ```rust
     #[test]
     fn test_hybrid_kem_roundtrip() {
         let keypair = tallow_web::crypto::WasmHybridKeyPair::generate().unwrap();
         let pub_key = keypair.public_key_bytes();
         let encap = tallow_web::crypto::WasmHybridKeyPair::encapsulate(&pub_key).unwrap();
         let shared_secret = keypair.decapsulate(&encap.ciphertext()).unwrap();
         assert_eq!(shared_secret, encap.shared_secret());
     }
     ```

  5. **Postcard codec consistency:**
     ```rust
     #[test]
     fn test_codec_consistency() {
         // Encode a message with tallow-web codec
         let room_id = vec![0xAA; 32];
         let web_bytes = tallow_web::codec::encode_room_join(&room_id, None).unwrap();

         // Decode with tallow-protocol directly
         let msg: tallow_protocol::wire::Message = postcard::from_bytes(&web_bytes).unwrap();
         match msg {
             tallow_protocol::wire::Message::RoomJoin { room_id: rid, password_hash } => {
                 assert_eq!(rid, room_id);
                 assert!(password_hash.is_none());
             }
             _ => panic!("Expected RoomJoin"),
         }
     }
     ```

  6. **Chunk AAD builder consistency:**
     Test that `build_chunk_aad()` and `build_chat_aad()` produce the same bytes as the CLI's AAD construction. Create a known input and verify byte-for-byte match.

  7. **Chat message encode/decode:**
     Test that `encrypt_chat_message()` produces a valid `Message::ChatText` that can be decoded by `postcard::from_bytes` and the ciphertext can be decrypted with the same key.

  IMPORTANT: These tests run on native target (not WASM). They verify that the tallow-web wrapper functions produce the same outputs as direct tallow-crypto calls. Since the same Rust code compiles to both native and WASM, this validates correctness.

  **Step 2: Add WebSocket relay bridge tests**

  In `crates/tallow-relay/src/websocket.rs`, add tests:

  1. **Length prefix addition test:**
     ```rust
     #[test]
     fn test_ws_to_quic_adds_length_prefix() {
         let ws_data = vec![0xDE, 0xAD, 0xBE, 0xEF]; // Raw postcard bytes from WS
         let quic_data = add_length_prefix(&ws_data);
         assert_eq!(&quic_data[..4], &(4u32).to_be_bytes());
         assert_eq!(&quic_data[4..], &ws_data);
     }
     ```

  2. **Length prefix stripping test:**
     ```rust
     #[test]
     fn test_quic_to_ws_strips_length_prefix() {
         let quic_data = vec![0, 0, 0, 4, 0xDE, 0xAD, 0xBE, 0xEF]; // 4-byte prefix + data
         let ws_data = strip_length_prefix(&quic_data).unwrap();
         assert_eq!(ws_data, vec![0xDE, 0xAD, 0xBE, 0xEF]);
     }
     ```

  3. **Room join parsing without length prefix:**
     ```rust
     #[test]
     fn test_ws_room_join_no_prefix() {
         // Browser sends raw postcard-encoded RoomJoin (no length prefix)
         let msg = tallow_protocol::wire::Message::RoomJoin {
             room_id: vec![0xAA; 32],
             password_hash: None,
         };
         let raw = postcard::to_stdvec(&msg).unwrap();
         // Parse should succeed (same parser, but applied to raw bytes not length-prefixed)
         let parsed = parse_room_join_dispatch(&raw).unwrap();
         // Verify room_id matches
     }
     ```

  Make the helper functions (`add_length_prefix`, `strip_length_prefix`) pub(crate) for testability, or test them via the public WS handler path.
  </action>
  <verify>
  `cargo test -p tallow-web` passes all crypto consistency tests. `cargo test -p tallow-relay` passes all WebSocket bridge tests. `cargo test --workspace` still passes (no regressions).
  </verify>
  <done>
  WASM crypto verification tests confirm: BLAKE3 hash, AES-256-GCM encrypt/decrypt, hybrid KEM round-trip, postcard codec, AAD builders, and chat message encoding all produce identical results between tallow-web wrappers and direct tallow-crypto calls. Relay WebSocket tests verify length-prefix bridging and room join parsing without prefix.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p tallow-web` — all crypto correctness tests pass
2. `cargo test -p tallow-relay` — all WebSocket bridge tests pass
3. `cargo test --workspace` — no regressions
4. web/manifest.json is valid
5. Service worker caches shell files
6. Build instructions in web/BUILD.md work end-to-end
7. PWA install prompt appears in Chrome when served over HTTPS
</verification>

<success_criteria>
- PWA manifest and service worker enable "Add to Home Screen" installation
- WASM crypto tests verify identical output between web wrapper and native crypto
- WebSocket bridge tests verify correct length-prefix handling
- Build instructions document the full WASM compilation pipeline
- All workspace tests pass (628+ existing + new tests)
</success_criteria>

<output>
After completion, create `.planning/phases/21-web-ui-browser-client/21-05-SUMMARY.md`
</output>
