---
phase: 21-web-ui-browser-client
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/tallow-web/Cargo.toml
  - crates/tallow-web/src/lib.rs
  - crates/tallow-web/src/crypto.rs
  - crates/tallow-web/src/codec.rs
  - crates/tallow-protocol/Cargo.toml
  - crates/tallow-protocol/src/wire/messages.rs
autonomous: true
requirements:
  - WEB-01
  - WEB-02
  - WEB-03

must_haves:
  truths:
    - "tallow-web crate compiles via cargo check on native target without errors (WASM cross-compilation verified in 21-05)"
    - "tallow-protocol 'wasm' feature compiles wire module without heavy deps (tokio, zstd, etc.)"
    - "All existing workspace crates still compile and pass tests after feature-gating"
    - "wasm-bindgen exports have valid signatures (no unsupported generics or lifetimes)"
    - "postcard-encoded Message variants can be constructed via codec.rs convenience functions"
    - "Argon2id is NOT in the browser handshake path — CPace PAKE uses BLAKE3, not Argon2id (verified by grep)"
  artifacts:
    - path: "crates/tallow-web/Cargo.toml"
      provides: "WASM cdylib crate with tallow-crypto + postcard + wasm-bindgen dependencies"
    - path: "crates/tallow-web/src/lib.rs"
      provides: "WASM entry point with panic hook initialization"
    - path: "crates/tallow-web/src/crypto.rs"
      provides: "wasm-bindgen wrappers for hybrid KEM, AES-256-GCM, BLAKE3, HKDF"
    - path: "crates/tallow-web/src/codec.rs"
      provides: "postcard encode/decode for Message enum via wasm-bindgen"
  key_links:
    - from: "crates/tallow-web/src/crypto.rs"
      to: "crates/tallow-crypto/src/kem/hybrid.rs"
      via: "direct import of tallow_crypto::kem::hybrid"
      pattern: "tallow_crypto::kem"
    - from: "crates/tallow-web/src/codec.rs"
      to: "crates/tallow-protocol/src/wire/messages.rs"
      via: "postcard serde of Message enum"
      pattern: "tallow_protocol::wire::Message"
---

<objective>
Create the tallow-web WASM crate that compiles tallow-crypto and the wire protocol Message enum to WebAssembly, exposing cryptographic operations and message encoding/decoding via wasm-bindgen.

Purpose: This is the foundation for all browser functionality. The browser MUST use the same cryptographic code as the CLI — no JS reimplementation. The WASM module provides hybrid KEM key exchange, AES-256-GCM encryption, BLAKE3 hashing, and postcard wire format encoding.

Output: A compilable tallow-web cdylib crate with wasm-bindgen exports for crypto and codec operations.
</objective>

<execution_context>
@C:/Users/Aamir/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Aamir/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-web-ui-browser-client/21-RESEARCH.md

@crates/tallow-crypto/Cargo.toml
@crates/tallow-crypto/src/kem/hybrid.rs
@crates/tallow-crypto/src/symmetric/aes_gcm.rs
@crates/tallow-crypto/src/hash/blake3.rs
@crates/tallow-crypto/src/kdf/hkdf.rs
@crates/tallow-protocol/src/wire/messages.rs
@crates/tallow-protocol/Cargo.toml
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Feature-gate tallow-protocol for WASM and create tallow-web crate</name>
  <files>
    crates/tallow-protocol/Cargo.toml
    crates/tallow-web/Cargo.toml
    crates/tallow-web/src/lib.rs
    Cargo.toml
  </files>
  <action>
  **Step 0: Audit Argon2id usage in browser handshake path**

  Before any code changes, verify that Argon2id (256MB memory) is NOT invoked during the browser's KEM handshake or CPace PAKE flow. Run:
  - `grep -r "argon2\|Argon2" crates/tallow-protocol/src/` — must return NO matches
  - `grep -r "argon2\|Argon2" crates/tallow-crypto/src/pake/` — must return NO matches (CPace uses blake3::derive_key)

  Result: Argon2id is only used in `tallow-crypto/src/kdf/argon2.rs` (password hashing) and `tallow-crypto/src/keys/storage.rs` (identity key storage encryption). Neither is in the browser handshake path. The tallow-web crate depends on tallow-crypto but will NOT call Argon2id functions — the browser uses CPace PAKE which derives session keys via BLAKE3, not Argon2id. No feature-gating is needed.

  If a future change adds Argon2id to the handshake path, it MUST be feature-gated out of tallow-web or reduced to browser-safe parameters (e.g., 64MB, 1 iteration). For now, no action required beyond this audit step.

  **Step 1: Feature-gate tallow-protocol for WASM compatibility**

  Add a `wasm` feature to `crates/tallow-protocol/Cargo.toml` that disables heavy dependencies (tokio, zstd, brotli, lz4_flex, lzma-rs, notify, ignore, tar, tokio-util, futures, img-parts, kamadak-exif, strip-ansi-escapes) so just the wire module (Message enum + postcard serde) compiles for wasm32-unknown-unknown. The wire module only needs `serde`, `postcard`, `blake3`, and `thiserror`.

  In Cargo.toml, restructure dependencies:
  ```toml
  [features]
  default = ["full"]
  full = ["dep:zstd", "dep:brotli", "dep:lz4_flex", "dep:lzma-rs", "dep:notify", "dep:ignore", "dep:tar", "dep:tokio", "dep:tokio-util", "dep:futures", "dep:img-parts", "dep:kamadak-exif", "dep:strip-ansi-escapes", "dep:tallow-net", "dep:bytes", "dep:rand", "dep:zeroize", "dep:subtle"]
  wasm = []
  ```

  Make tallow-crypto, tallow-net, and all heavy deps optional (only included in `full` feature). Keep `serde`, `postcard`, `blake3`, `thiserror`, `serde_json` as always-on since they're needed for wire format.

  CRITICAL: The existing `tallow-protocol` dependency in other crates (tallow, tallow-relay) must use `features = ["full"]` or `default-features = true` to maintain current behavior. Update their Cargo.toml entries to explicitly enable the `full` feature.

  Add `#[cfg(feature = "full")]` gates around module declarations in `crates/tallow-protocol/src/lib.rs` for: transfer, compression, room (except the parts needed by wire), chat, metadata. The `wire` module must always be available.

  **Step 2: Create tallow-web crate**

  Create `crates/tallow-web/` directory with `Cargo.toml`:
  ```toml
  [package]
  name = "tallow-web"
  version.workspace = true
  edition.workspace = true
  license.workspace = true
  description = "WebAssembly module for Tallow browser client"

  [lib]
  crate-type = ["cdylib", "rlib"]

  [dependencies]
  tallow-crypto = { path = "../tallow-crypto" }
  tallow-protocol = { path = "../tallow-protocol", default-features = false, features = ["wasm"] }

  wasm-bindgen = "0.2"
  web-sys = { version = "0.3", features = ["console"] }
  js-sys = "0.3"
  wasm-bindgen-futures = "0.4"
  serde = { version = "1", features = ["derive"] }
  serde-wasm-bindgen = "0.6"
  postcard = { version = "1.1", features = ["use-std"] }
  getrandom = { version = "0.2", features = ["wasm_js"] }
  console_error_panic_hook = "0.1"
  ```

  CRITICAL: `getrandom` with `wasm_js` feature MUST be a direct dependency (not just transitive) to ensure the feature is active for all crypto deps.

  Create `crates/tallow-web/src/lib.rs`:
  ```rust
  #![forbid(unsafe_code)]
  //! WebAssembly module for Tallow browser client
  //!
  //! Provides crypto operations and wire protocol encoding/decoding
  //! via wasm-bindgen for use in the browser.

  use wasm_bindgen::prelude::*;

  pub mod crypto;
  pub mod codec;

  /// Initialize the WASM module (called automatically on load)
  #[wasm_bindgen(start)]
  pub fn init() {
      console_error_panic_hook::set_once();
  }
  ```

  **Step 3: Add tallow-web to workspace**

  Add `"crates/tallow-web"` to the workspace members list in the root `Cargo.toml`.

  NOTE: Do NOT add tallow-web to the default workspace build. Since it targets wasm32-unknown-unknown, it should only be built explicitly with `--target wasm32-unknown-unknown`. To exclude it from regular `cargo build --workspace`, add it to `[workspace]` members but also add `exclude = []` for documentation, or gate it so `cargo build --workspace` on native targets still works. The simplest approach: keep it in workspace members but ensure its dependencies all compile on native too (they do — wasm-bindgen, web-sys, etc. compile on native as no-ops). This way `cargo check --workspace` works for linting.
  </action>
  <verify>
  1. Argon2id audit: `grep -r "argon2\|Argon2" crates/tallow-protocol/src/` returns no matches. `grep -r "argon2\|Argon2" crates/tallow-crypto/src/pake/` returns no matches.
  2. Install wasm32 target: `rustup target add wasm32-unknown-unknown` (required for WASM compilation in later plans).
  3. Run `powershell.exe -NoProfile -Command "& { $env:PATH = 'C:\Users\Aamir\.rustup\toolchains\stable-x86_64-pc-windows-msvc\bin;' + $env:PATH; $env:LIB = 'C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\14.43.34808\lib\x64;C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0\um\x64;C:\Program Files (x86)\Windows Kits\10\Lib\10.0.26100.0\ucrt\x64'; $env:INCLUDE = 'C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\14.43.34808\include;C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt;C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um;C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared'; cargo check -p tallow-web 2>&1 }"` passes without errors.
  4. Verify `cargo check --workspace` still passes (existing crates unbroken).
  </verify>
  <done>
  tallow-web crate exists in workspace with cdylib target, depends on tallow-crypto + tallow-protocol (wasm feature), getrandom wasm_js enabled. tallow-protocol has `wasm` feature that compiles only the wire module. All existing crates still compile.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement WASM crypto wrappers and codec bindings</name>
  <files>
    crates/tallow-web/src/crypto.rs
    crates/tallow-web/src/codec.rs
  </files>
  <action>
  **Step 1: Create crypto.rs — wasm-bindgen wrappers for tallow-crypto**

  Create `crates/tallow-web/src/crypto.rs` with thin wasm-bindgen wrappers around tallow-crypto functions. Each function catches Rust errors and returns `Result<T, JsValue>`:

  1. **Hybrid KEM key pair generation:**
     - `WasmHybridKeyPair` struct wrapping `tallow_crypto::kem::hybrid::HybridKeyPair`
     - `#[wasm_bindgen(constructor)] pub fn generate() -> Result<WasmHybridKeyPair, JsValue>`
     - `pub fn public_key_bytes(&self) -> Vec<u8>` — serialized hybrid public key
     - `pub fn encapsulate(public_key_bytes: &[u8]) -> Result<WasmEncapsulated, JsValue>` — returns ciphertext + shared secret
     - `pub fn decapsulate(&self, ciphertext: &[u8]) -> Result<Vec<u8>, JsValue>` — returns shared secret

  2. **AES-256-GCM encryption/decryption:**
     - `pub fn aes_gcm_encrypt(key: &[u8], nonce_counter: u64, aad: &[u8], plaintext: &[u8]) -> Result<Vec<u8>, JsValue>`
     - `pub fn aes_gcm_decrypt(key: &[u8], nonce_counter: u64, aad: &[u8], ciphertext: &[u8]) -> Result<Vec<u8>, JsValue>`
     - These call directly into `tallow_crypto::symmetric::aes_gcm_encrypt` / `aes_gcm_decrypt` (or the equivalent API). Look at the actual function signatures in tallow-crypto/src/symmetric/ and wrap them exactly.

  3. **BLAKE3 hashing:**
     - `pub fn blake3_hash(data: &[u8]) -> Vec<u8>` — returns 32-byte hash
     - `pub fn blake3_keyed_hash(key: &[u8], data: &[u8]) -> Result<Vec<u8>, JsValue>`

  4. **HKDF key derivation:**
     - `pub fn hkdf_derive(ikm: &[u8], salt: &[u8], info: &[u8], length: usize) -> Result<Vec<u8>, JsValue>`
     - Wraps `tallow_crypto::kdf::hkdf::derive_session_key_with_salt` or the HKDF expand API.

  5. **Nonce/AAD builders for file chunks and chat:**
     - `pub fn build_chunk_aad(transfer_id: &[u8], chunk_index: u64) -> Vec<u8>` — domain-separated AAD for file chunks
     - `pub fn build_chat_aad(transfer_id: &[u8], sequence: u64) -> Vec<u8>` — domain-separated AAD for chat messages
     - These must produce IDENTICAL output to the CLI's AAD construction. Read the existing AAD building code in tallow-protocol/src/transfer/ and replicate the exact byte layout.

  6. **Random bytes:**
     - `pub fn random_bytes(len: usize) -> Vec<u8>` — uses getrandom (which routes to crypto.getRandomValues in WASM)

  IMPORTANT: Look at the ACTUAL API signatures in tallow-crypto before writing wrappers. The functions may have different names or signatures than assumed. For example, check if encrypt/decrypt take a `NonceCounter` type vs raw u64, if keys are `&[u8]` or wrapped types, etc.

  **Step 2: Create codec.rs — postcard encode/decode for Message enum**

  Create `crates/tallow-web/src/codec.rs` with:

  1. `pub fn encode_message(msg: JsValue) -> Result<Vec<u8>, JsValue>` — takes a JS object, converts to Message via serde-wasm-bindgen, encodes with postcard
  2. `pub fn decode_message(bytes: &[u8]) -> Result<JsValue, JsValue>` — decodes postcard bytes to Message, converts to JS via serde-wasm-bindgen

  3. Convenience constructors for common messages (avoiding complex JS-to-Rust conversion):
     - `pub fn encode_room_join(room_id: &[u8], password_hash: Option<Vec<u8>>) -> Result<Vec<u8>, JsValue>`
     - `pub fn encode_handshake_init(protocol_version: u32, kem_capabilities: &[u8], cpace_public: &[u8], nonce: &[u8]) -> Result<Vec<u8>, JsValue>`
     - `pub fn encode_handshake_response(selected_kem: u8, cpace_public: &[u8], kem_public_key: &[u8], nonce: &[u8]) -> Result<Vec<u8>, JsValue>`
     - `pub fn encode_handshake_kem(kem_ciphertext: &[u8], confirmation: &[u8]) -> Result<Vec<u8>, JsValue>`
     - `pub fn encode_handshake_complete(confirmation: &[u8]) -> Result<Vec<u8>, JsValue>`
     - `pub fn encode_file_offer(transfer_id: &[u8], manifest: &[u8]) -> Result<Vec<u8>, JsValue>`
     - `pub fn encode_file_accept(transfer_id: &[u8]) -> Result<Vec<u8>, JsValue>`
     - `pub fn encode_chunk(transfer_id: &[u8], index: u64, total: Option<u64>, data: &[u8]) -> Result<Vec<u8>, JsValue>`
     - `pub fn encode_ack(transfer_id: &[u8], index: u64) -> Result<Vec<u8>, JsValue>`
     - `pub fn encode_transfer_complete(transfer_id: &[u8], hash: &[u8], merkle_root: Option<Vec<u8>>) -> Result<Vec<u8>, JsValue>`
     - `pub fn encode_chat_text(message_id: &[u8], sequence: u64, ciphertext: &[u8], nonce: &[u8]) -> Result<Vec<u8>, JsValue>`
     - `pub fn encode_typing_indicator(typing: bool) -> Result<Vec<u8>, JsValue>`
     - `pub fn encode_chat_end() -> Result<Vec<u8>, JsValue>`

  Each convenience function constructs the appropriate `Message` variant from raw bytes, then serializes with `postcard::to_stdvec`.

  IMPORTANT: For `transfer_id: &[u8]` parameters that need `[u8; 16]`, validate the length and copy into a fixed array. Same for `hash: &[u8]` needing `[u8; 32]`. Return clear JsValue errors on wrong lengths.
  </action>
  <verify>
  `cargo check -p tallow-web` passes. Verify function signatures match actual tallow-crypto APIs by cross-referencing source files. All #[wasm_bindgen] exports have correct types (no unsupported generics, no lifetimes in return types).
  </verify>
  <done>
  crypto.rs provides wasm-bindgen exports for: hybrid KEM generate/encapsulate/decapsulate, AES-256-GCM encrypt/decrypt, BLAKE3 hash, HKDF derive, chunk/chat AAD builders, random bytes. codec.rs provides generic encode/decode plus convenience constructors for all protocol messages needed by the browser client. Both compile without errors.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p tallow-web` compiles without errors on native target
2. `cargo check --workspace` still passes (no regressions in existing crates)
3. `cargo test -p tallow-protocol` still passes (feature gate doesn't break tests)
4. tallow-web/src/crypto.rs exports match actual tallow-crypto function signatures
5. tallow-web/src/codec.rs can construct and serialize all Message variants used by the browser
</verification>

<success_criteria>
- tallow-web crate exists with cdylib output target
- tallow-crypto compiles as a dependency of tallow-web (WASM-compatible)
- Wire protocol Message enum accessible via tallow-protocol's `wasm` feature without heavy deps
- wasm-bindgen exports cover: KEM, AES-GCM, BLAKE3, HKDF, postcard codec
- getrandom uses wasm_js feature for browser crypto.getRandomValues()
- All existing workspace crates still compile and pass tests
</success_criteria>

<output>
After completion, create `.planning/phases/21-web-ui-browser-client/21-01-SUMMARY.md`
</output>
