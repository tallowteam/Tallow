---
phase: 21-web-ui-browser-client
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/tallow-web/Cargo.toml
  - crates/tallow-web/src/lib.rs
  - crates/tallow-web/src/crypto.rs
  - crates/tallow-web/src/codec.rs
  - crates/tallow-protocol/Cargo.toml
  - crates/tallow-protocol/src/wire/mod.rs
  - crates/tallow-protocol/src/wire/messages.rs
  - crates/tallow-protocol/src/transfer/sanitize.rs
  - crates/tallow-crypto/Cargo.toml
autonomous: true
requirements:
  - WEB-01
  - WEB-02
  - WEB-03
  - WEB-18

must_haves:
  truths:
    - "tallow-crypto compiles to wasm32-unknown-unknown without errors"
    - "tallow-web cdylib crate exposes hybrid KEM, AES-256-GCM encrypt/decrypt, BLAKE3 hash, HKDF, and postcard encode/decode via wasm-bindgen"
    - "tallow-protocol with feature='wasm' compiles to wasm32-unknown-unknown (Message enum + postcard + sanitize_display only, no tokio/zstd/tar)"
    - "WASM crypto produces identical output to native for KEM encapsulate/decapsulate, AES-GCM encrypt/decrypt, BLAKE3 hash"
  artifacts:
    - path: "crates/tallow-web/Cargo.toml"
      provides: "WASM cdylib crate configuration"
      contains: "crate-type = [\"cdylib\"]"
    - path: "crates/tallow-web/src/lib.rs"
      provides: "WASM entry point with panic hook"
      contains: "console_error_panic_hook"
    - path: "crates/tallow-web/src/crypto.rs"
      provides: "wasm-bindgen wrappers for hybrid KEM, AES-GCM, BLAKE3, HKDF"
      contains: "#[wasm_bindgen]"
    - path: "crates/tallow-web/src/codec.rs"
      provides: "Postcard encode/decode wrappers for Message enum"
      contains: "postcard::from_bytes"
    - path: "crates/tallow-protocol/Cargo.toml"
      provides: "wasm feature gate"
      contains: "wasm"
  key_links:
    - from: "crates/tallow-web/src/crypto.rs"
      to: "crates/tallow-crypto"
      via: "direct crate import"
      pattern: "use tallow_crypto"
    - from: "crates/tallow-web/src/codec.rs"
      to: "crates/tallow-protocol/src/wire/messages.rs"
      via: "feature-gated import"
      pattern: "tallow_protocol::wire"
---

<objective>
Create the tallow-web WASM crate and feature-gate tallow-protocol for browser compilation.

Purpose: This is the foundation for all browser functionality. The tallow-web crate wraps tallow-crypto operations (hybrid KEM, AES-256-GCM, BLAKE3, HKDF) and postcard message encoding via wasm-bindgen, so the browser uses identical crypto code paths to the CLI. Feature-gating tallow-protocol ensures the Message enum + sanitize_display compile to WASM without pulling in heavy native-only dependencies (tokio, zstd, tar, notify).

Output: A new `crates/tallow-web` crate that compiles to wasm32-unknown-unknown, exposing crypto and codec functions to JavaScript.
</objective>

<execution_context>
@C:/Users/Aamir/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Aamir/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@crates/tallow-crypto/Cargo.toml
@crates/tallow-crypto/src/lib.rs
@crates/tallow-crypto/src/kem/hybrid.rs
@crates/tallow-crypto/src/symmetric/mod.rs
@crates/tallow-crypto/src/hash/mod.rs
@crates/tallow-crypto/src/kdf/mod.rs
@crates/tallow-protocol/Cargo.toml
@crates/tallow-protocol/src/wire/messages.rs
@crates/tallow-protocol/src/wire/mod.rs
@crates/tallow-protocol/src/transfer/sanitize.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Feature-gate tallow-protocol for WASM and create tallow-web crate structure</name>
  <files>
    Cargo.toml
    crates/tallow-web/Cargo.toml
    crates/tallow-web/src/lib.rs
    crates/tallow-protocol/Cargo.toml
    crates/tallow-protocol/src/wire/mod.rs
    crates/tallow-protocol/src/wire/messages.rs
    crates/tallow-protocol/src/transfer/sanitize.rs
    crates/tallow-protocol/src/transfer/mod.rs
    crates/tallow-crypto/Cargo.toml
  </files>
  <action>
    **Step 1: Feature-gate tallow-protocol**

    In `crates/tallow-protocol/Cargo.toml`, add a `wasm` feature:
    ```toml
    [features]
    default = ["full"]
    full = []
    wasm = []
    ```

    Gate ALL heavy dependencies behind `full` (not `wasm`). The `wasm` feature should enable only what's needed:
    - Dependencies that stay for `wasm`: `serde`, `postcard` (with `default-features = false, features = ["alloc"]` under wasm), `thiserror`, `blake3`, `zeroize`, `subtle`
    - Dependencies gated behind `full` (or `not(feature = "wasm")`): `tallow-net`, `zstd`, `brotli`, `lz4_flex`, `lzma-rs`, `notify`, `ignore`, `tar`, `tokio`, `tokio-util`, `futures`, `serde_json`, `bytes`, `rand`, `img-parts`, `kamadak-exif`, `strip-ansi-escapes`
    - `tallow-crypto` stays as a dependency for both (it compiles to WASM)

    Use `#[cfg(feature = "full")]` gates in `wire/mod.rs` to conditionally compile the codec module (which uses tokio-util). The `messages.rs` file with the Message enum must always compile. In `transfer/mod.rs`, gate all submodules except `sanitize` behind `#[cfg(feature = "full")]`. The `sanitize` module must always compile (needed in browser).

    For `sanitize.rs`: check if it uses `strip-ansi-escapes` — if so, gate that usage behind `#[cfg(feature = "full")]` and provide a simpler WASM-compatible fallback that strips ANSI using a basic state machine or the same logic without the VTE dependency.

    Ensure `postcard` dependency uses conditional features:
    ```toml
    # Under [dependencies]
    postcard = { version = "1.1", default-features = false, features = ["alloc"] }
    # Or use a feature-conditional approach
    ```
    Actually, since the workspace pins `postcard` with `use-std`, use a direct dependency override in tallow-protocol:
    ```toml
    postcard = { workspace = true }  # keeps use-std for full
    ```
    And in tallow-web's Cargo.toml, use `postcard = { version = "1.1", default-features = false, features = ["alloc"] }` directly.

    **Step 2: Create tallow-web crate**

    Add `"crates/tallow-web"` to workspace members in root `Cargo.toml`.

    Create `crates/tallow-web/Cargo.toml`:
    ```toml
    [package]
    name = "tallow-web"
    version.workspace = true
    edition.workspace = true
    license.workspace = true
    description = "WebAssembly browser client for Tallow file transfers"

    [lib]
    crate-type = ["cdylib"]

    [dependencies]
    tallow-crypto = { path = "../tallow-crypto" }
    tallow-protocol = { path = "../tallow-protocol", default-features = false, features = ["wasm"] }

    # WASM bindings
    wasm-bindgen = "0.2"
    web-sys = { version = "0.3", features = [
        "console",
    ] }
    js-sys = "0.3"
    wasm-bindgen-futures = "0.4"
    console_error_panic_hook = "0.1"

    # Serialization (WASM-compatible, no std)
    serde = { version = "1", features = ["derive"] }
    postcard = { version = "1.1", default-features = false, features = ["alloc"] }

    # Crypto randomness in browser
    getrandom = { version = "0.2", features = ["js"] }

    # Serde-JsValue bridge
    serde-wasm-bindgen = "0.6"
    ```

    CRITICAL: `getrandom = { version = "0.2", features = ["js"] }` MUST be a direct dependency. The feature name is `"js"` (NOT `"wasm_js"` — that's getrandom 0.3+). Without this, crypto.getRandomValues() won't be wired and all crypto operations will panic at runtime.

    Create `crates/tallow-web/src/lib.rs`:
    ```rust
    //! Tallow WebAssembly browser client
    //!
    //! Thin wasm-bindgen wrapper over tallow-crypto and tallow-protocol wire types.
    //! The browser uses identical cryptographic code paths to the CLI.
    #![forbid(unsafe_code)]

    pub mod crypto;
    pub mod codec;

    use wasm_bindgen::prelude::*;

    /// Initialize WASM module (called automatically on load via #[wasm_bindgen(start)])
    #[wasm_bindgen(start)]
    pub fn init() {
        console_error_panic_hook::set_once();
    }
    ```

    **Step 3: Verify tallow-crypto compiles to WASM**

    Check `crates/tallow-crypto/Cargo.toml` — the `libc` dependency is already gated behind `cfg(unix)`. The `fips203`, `x25519-dalek`, `aes-gcm`, `blake3`, `hkdf`, `sha2` crates are all pure Rust no_std. The `argon2` crate may need checking — if it's in the WASM path, verify it compiles. For Phase 21, Argon2id is NOT in the browser handshake path (room ID uses BLAKE3, handshake uses KEM+CPace). If there are any cfg(unix) blocks in source files (mlock, core dump prevention), they should already have no-op fallbacks.

    Verify compilation with: `cargo build -p tallow-web --target wasm32-unknown-unknown` (use PowerShell wrapper). This is the critical gate — if it compiles, WEB-01 is satisfied.
  </action>
  <verify>
    Run `cargo build -p tallow-web --target wasm32-unknown-unknown` (via PowerShell wrapper with MSVC env vars). The build must complete without errors. Run `cargo test -p tallow-protocol --features full` to verify existing tests still pass with the new feature gates. Run `cargo clippy -p tallow-web --target wasm32-unknown-unknown` for lint check.
  </verify>
  <done>
    tallow-web crate exists in workspace, compiles to wasm32-unknown-unknown. tallow-protocol `wasm` feature compiles only wire/messages.rs + sanitize_display without tokio/zstd/tar. tallow-crypto compiles to WASM target. All existing tallow-protocol tests pass with `--features full`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement wasm-bindgen crypto wrappers and postcard codec</name>
  <files>
    crates/tallow-web/src/crypto.rs
    crates/tallow-web/src/codec.rs
  </files>
  <action>
    **crypto.rs — Thin wasm-bindgen wrappers over tallow-crypto:**

    All functions return `Result<T, JsValue>` where errors are string-converted.

    1. **WasmKeyPair** struct wrapping `tallow_crypto::kem::hybrid::HybridKeyPair`:
       - `WasmKeyPair::generate() -> Result<WasmKeyPair, JsValue>` — generates ephemeral ML-KEM-1024 + X25519 hybrid keypair
       - `public_key_bytes(&self) -> Vec<u8>` — returns serialized public key
       - `encapsulate(public_key: &[u8]) -> Result<WasmEncapsulated, JsValue>` — KEM encapsulate against a peer's public key
       - `decapsulate(ciphertext: &[u8]) -> Result<Vec<u8>, JsValue>` — KEM decapsulate to get shared secret

    2. **WasmEncapsulated** struct:
       - `ciphertext(&self) -> Vec<u8>`
       - `shared_secret(&self) -> Vec<u8>`

    3. **Symmetric encryption functions:**
       - `encrypt_chunk(key: &[u8], nonce_counter: u64, aad: &[u8], plaintext: &[u8]) -> Result<Vec<u8>, JsValue>` — AES-256-GCM encrypt
       - `decrypt_chunk(key: &[u8], nonce_counter: u64, aad: &[u8], ciphertext: &[u8]) -> Result<Vec<u8>, JsValue>` — AES-256-GCM decrypt

    4. **Hashing:**
       - `blake3_hash(data: &[u8]) -> Vec<u8>` — BLAKE3 hash (32 bytes)
       - `blake3_derive_room_id(code_phrase: &str) -> Vec<u8>` — BLAKE3 keyed hash for room ID derivation (must match CLI's room ID derivation exactly)

    5. **KDF:**
       - `hkdf_derive(ikm: &[u8], salt: &[u8], info: &[u8], output_len: u32) -> Result<Vec<u8>, JsValue>` — HKDF-SHA256

    6. **Chat encryption helpers:**
       - `encrypt_chat_message(key: &[u8], counter: u64, plaintext: &str) -> Result<Vec<u8>, JsValue>` — AES-256-GCM with nonce `[0u8;4]||counter.to_be_bytes()`, AAD `b"tallow-chat-v1"`, counter increments by 2
       - `decrypt_chat_message(key: &[u8], counter: u64, ciphertext: &[u8]) -> Result<String, JsValue>` — Decrypt and return UTF-8 string

    Look at the actual tallow-crypto API to call the right functions. The hybrid KEM module is at `tallow_crypto::kem::hybrid`. Symmetric encryption is at `tallow_crypto::symmetric`. Hashing at `tallow_crypto::hash`. KDF at `tallow_crypto::kdf`. Map these to the wasm-bindgen exports.

    IMPORTANT: Do NOT use `.unwrap()` anywhere — all errors must be converted via `.map_err(|e| JsValue::from_str(&e.to_string()))`.

    **codec.rs — Postcard encode/decode for Message enum:**

    Import `tallow_protocol::wire::messages::Message` (available under `wasm` feature).

    1. `encode_message(msg: JsValue) -> Result<Vec<u8>, JsValue>` — deserialize JsValue to Message via serde-wasm-bindgen, then postcard-encode
    2. `decode_message(bytes: &[u8]) -> Result<JsValue, JsValue>` — postcard-decode to Message, then serialize to JsValue via serde-wasm-bindgen
    3. `encode_room_join(room_id: &[u8], password_hash: Option<Vec<u8>>) -> Result<Vec<u8>, JsValue>` — convenience: build RoomJoin message and encode
    4. `encode_file_offer(transfer_id: &[u8], manifest: &[u8]) -> Result<Vec<u8>, JsValue>` — build FileOffer and encode
    5. `encode_chunk(transfer_id: &[u8], index: u64, total: Option<u64>, data: &[u8]) -> Result<Vec<u8>, JsValue>` — build Chunk and encode
    6. `encode_file_accept(transfer_id: &[u8]) -> Result<Vec<u8>, JsValue>` — build FileAccept and encode
    7. `encode_chat_text(message_id: &[u8], sequence: u64, ciphertext: &[u8], nonce: &[u8]) -> Result<Vec<u8>, JsValue>` — build ChatText and encode
    8. `encode_typing_indicator(typing: bool) -> Result<Vec<u8>, JsValue>` — build TypingIndicator and encode
    9. `encode_handshake_init(protocol_version: u32, kem_capabilities: &[u8], cpace_public: &[u8], nonce: &[u8]) -> Result<Vec<u8>, JsValue>` — build HandshakeInit and encode
    10. `encode_handshake_response(selected_kem: u8, cpace_public: &[u8], kem_public_key: &[u8], nonce: &[u8]) -> Result<Vec<u8>, JsValue>` — build HandshakeResponse and encode
    11. `sanitize_display_text(input: &str) -> String` — wraps tallow_protocol sanitize_display

    Use `postcard::to_allocvec()` (NOT `to_stdvec()`) since the WASM context uses alloc, not std.

    All functions annotated with `#[wasm_bindgen]`. For fixed-size arrays like `transfer_id: [u8; 16]`, accept `&[u8]` and validate length, returning error if wrong size.
  </action>
  <verify>
    Run `cargo build -p tallow-web --target wasm32-unknown-unknown --release`. Verify the WASM output exists at `target/wasm32-unknown-unknown/release/tallow_web.wasm`. Check binary size (should be under 5MB uncompressed). Run `cargo clippy -p tallow-web --target wasm32-unknown-unknown -- -D warnings`.
  </verify>
  <done>
    crypto.rs exposes WasmKeyPair (generate, encapsulate, decapsulate, public_key_bytes), encrypt_chunk, decrypt_chunk, blake3_hash, blake3_derive_room_id, hkdf_derive, encrypt_chat_message, decrypt_chat_message. codec.rs exposes encode/decode for all message types needed by the browser (RoomJoin, HandshakeInit/Response/Kem/Complete, FileOffer, FileAccept, Chunk, Ack, ChatText, TypingIndicator) plus sanitize_display_text. All compile to wasm32-unknown-unknown. WEB-01, WEB-02, WEB-03, WEB-18 satisfied.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p tallow-web --target wasm32-unknown-unknown --release` succeeds (WEB-01)
2. `cargo clippy -p tallow-web --target wasm32-unknown-unknown -- -D warnings` passes clean
3. `cargo test -p tallow-protocol --features full` — all existing tests pass (backward compat)
4. `cargo test -p tallow-protocol --features wasm` — Message roundtrip tests pass under wasm feature
5. The WASM binary at `target/wasm32-unknown-unknown/release/tallow_web.wasm` exists and is under 5MB
6. wasm-bindgen exports include: WasmKeyPair, encrypt_chunk, decrypt_chunk, blake3_hash, encode_message, decode_message, sanitize_display_text
</verification>

<success_criteria>
- tallow-crypto compiles to wasm32-unknown-unknown (WEB-01)
- tallow-web cdylib exposes hybrid KEM, AES-GCM, BLAKE3, HKDF, postcard encode/decode (WEB-02)
- tallow-protocol `wasm` feature compiles without tokio/zstd/tar (WEB-03)
- Crypto wrappers call the same Rust code as CLI (WEB-18 foundation)
</success_criteria>

<output>
After completion, create `.planning/phases/21-web-ui-browser-client/21-01-SUMMARY.md`
</output>
